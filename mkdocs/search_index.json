{
    "docs": [
        {
            "location": "/",
            "text": "Venngage Coding Guidelines\n\n\n\n\nTable of Contents\n\n\n\n\nJavascript Styleguide\n\n\nReact\n\n\nCSS in Javascript\n\n\nPHP Styleguide\n\n\nLicense",
            "title": "Home"
        },
        {
            "location": "/#venngage-coding-guidelines",
            "text": "",
            "title": "Venngage Coding Guidelines"
        },
        {
            "location": "/#table-of-contents",
            "text": "Javascript Styleguide  React  CSS in Javascript  PHP Styleguide  License",
            "title": "Table of Contents"
        },
        {
            "location": "/js/javascript/",
            "text": "Venngage JavaScript Style Guide\n\n\n\n\nBased off of \nAirBnB's style guide.\n\n\n\n\nTypes\n\n\nReferences\n\n\nObjects\n\n\nArrays\n\n\nDestructuring\n\n\nStrings\n\n\nFunctions\n\n\nArrow Functions\n\n\nClasses \n Constructors\n\n\nModules\n\n\nIterators and Generators\n\n\nProperties\n\n\nVariables\n\n\nHoisting\n\n\nComparison Operators \n Equality\n\n\nBlocks\n\n\nComments\n\n\nWhitespace\n\n\nCommas\n\n\nSemicolons\n\n\nType Casting \n Coercion\n\n\nNaming Conventions\n\n\nAccessors\n\n\nEvents\n\n\nECMAScript 6+ (ES 2015+) Styles\n\n\nTesting\n\n\nPerformance\n\n\nResources\n\n\n\n\nTypes\n\n\n\n\n\n\n\n\n1.1\n \nPrimitives\n: When you access a primitive type you work directly on its value.\n\n\n\n\n\n\nstring\n\n\n\n\nnumber\n\n\nboolean\n\n\nnull\n\n\nundefined\n\n\n\n\nconst\n \nfoo\n \n=\n \n1\n;\n\n\nlet\n \nbar\n \n=\n \nfoo\n;\n\n\n\nbar\n \n=\n \n9\n;\n\n\n\nconsole\n.\nlog\n(\nfoo\n,\n \nbar\n);\n \n// =\n 1, 9\n\n\n\n\n\n\n\n\n\n\n1.2\n  \nComplex\n: When you access a complex type you work on a reference to its value.\n\n\n\n\n\n\nobject\n\n\n\n\narray\n\n\nfunction\n\n\n\n\nconst\n \nfoo\n \n=\n \n[\n1\n,\n \n2\n];\n\n\nconst\n \nbar\n \n=\n \nfoo\n;\n\n\n\nbar\n[\n0\n]\n \n=\n \n9\n;\n\n\n\nconsole\n.\nlog\n(\nfoo\n[\n0\n],\n \nbar\n[\n0\n]);\n \n// =\n 9, 9\n\n\n\n\n\n\n\u2b06 back to top\n\n\nReferences\n\n\n\n\n\n\n2.1\n Use \nconst\n for all of your references; avoid using \nvar\n. eslint: \nprefer-const\n, \nno-const-assign\n\n\n\n\n\n\nTip\n\n\nThis ensures that you can't reassign your references, which can lead to bugs and difficult to comprehend code.\n\n\n\n\n// bad\n\n\nvar\n \na\n \n=\n \n1\n;\n\n\nvar\n \nb\n \n=\n \n2\n;\n\n\n\n// good\n\n\nconst\n \na\n \n=\n \n1\n;\n\n\nconst\n \nb\n \n=\n \n2\n;\n\n\n\n\n\n\n\n\n2.2\n If you must reassign references, use \nlet\n instead of \nvar\n. eslint: \nno-var\n jscs: \ndisallowVar\n\n\n\n\n\n\nWhy? \nlet\n is block-scoped rather than function-scoped like \nvar\n.\n\n\n\n\n// bad\n\n\nvar\n \ncount\n \n=\n \n1\n;\n\n\nif\n \n(\ntrue\n)\n \n{\n\n\ncount\n \n+=\n \n1\n;\n\n\n}\n\n\n\n// good, use the let.\n\n\nlet\n \ncount\n \n=\n \n1\n;\n\n\nif\n \n(\ntrue\n)\n \n{\n\n\ncount\n \n+=\n \n1\n;\n\n\n}\n\n\n\n\n\n\n\n\n2.3\n Note that both \nlet\n and \nconst\n are block-scoped.\n\n\n\n\n// const and let only exist in the blocks they are defined in.\n\n\n{\n\n\nlet\n \na\n \n=\n \n1\n;\n\n\nconst\n \nb\n \n=\n \n1\n;\n\n\n}\n\n\nconsole\n.\nlog\n(\na\n);\n \n// ReferenceError\n\n\nconsole\n.\nlog\n(\nb\n);\n \n// ReferenceError\n\n\n\n\n\n\n\u2b06 back to top\n\n\nObjects\n\n\n\n\n\n\n3.1\n Use the literal syntax for object creation. eslint: \nno-new-object\n\n\n\n\n// bad\n\n\nconst\n \nitem\n \n=\n \nnew\n \nObject\n();\n\n\n\n// good\n\n\nconst\n \nitem\n \n=\n \n{};\n\n\n\n\n\n\n\n\n3.2\n Use computed property names when creating objects with dynamic property names.\n\n\n\n\n\n\nWhy? They allow you to define all the properties of an object in one place.\n\n\n\n\nfunction\n \ngetKey\n(\nk\n)\n \n{\n\n\nreturn\n \n`a key named \n${\nk\n}\n`\n;\n\n\n}\n\n\n\n// bad\n\n\nconst\n \nobj\n \n=\n \n{\n\n\nid\n:\n \n5\n,\n\n\nname\n:\n \nSan Francisco\n,\n\n\n};\n\n\nobj\n[\ngetKey\n(\nenabled\n)]\n \n=\n \ntrue\n;\n\n\n\n// good\n\n\nconst\n \nobj\n \n=\n \n{\n\n\nid\n:\n \n5\n,\n\n\nname\n:\n \nSan Francisco\n,\n\n\n[\ngetKey\n(\nenabled\n)]\n:\n \ntrue\n,\n\n\n};\n\n\n\n\n\n\n\n\n3.3\n Use object method shorthand. eslint: \nobject-shorthand\n jscs: \nrequireEnhancedObjectLiterals\n\n\n\n\n// bad\n\n\nconst\n \natom\n \n=\n \n{\n\n\nvalue\n:\n \n1\n,\n\n\n\naddValue\n:\n \nfunction\n \n(\nvalue\n)\n \n{\n\n  \nreturn\n \natom\n.\nvalue\n \n+\n \nvalue\n;\n\n\n},\n\n\n};\n\n\n\n// good\n\n\nconst\n \natom\n \n=\n \n{\n\n\nvalue\n:\n \n1\n,\n\n\n\naddValue\n(\nvalue\n)\n \n{\n\n  \nreturn\n \natom\n.\nvalue\n \n+\n \nvalue\n;\n\n\n},\n\n\n};\n\n\n\n\n\n\n\n\n3.4\n Use property value shorthand. eslint: \nobject-shorthand\n jscs: \nrequireEnhancedObjectLiterals\n\n\n\n\n\n\nWhy? It is shorter to write and descriptive.\n\n\n\n\nconst\n \nlukeSkywalker\n \n=\n \nLuke Skywalker\n;\n\n\n\n// bad\n\n\nconst\n \nobj\n \n=\n \n{\n\n\nlukeSkywalker\n:\n \nlukeSkywalker\n,\n\n\n};\n\n\n\n// good\n\n\nconst\n \nobj\n \n=\n \n{\n\n\nlukeSkywalker\n,\n\n\n};\n\n\n\n\n\n\n\n\n3.5\n Group your shorthand properties at the beginning of your object declaration.\n\n\n\n\n\n\nWhy? It's easier to tell which properties are using the shorthand.\n\n\n\n\nconst\n \nanakinSkywalker\n \n=\n \nAnakin Skywalker\n;\n\n\nconst\n \nlukeSkywalker\n \n=\n \nLuke Skywalker\n;\n\n\n\n// bad\n\n\nconst\n \nobj\n \n=\n \n{\n\n\nepisodeOne\n:\n \n1\n,\n\n\ntwoJediWalkIntoACantina\n:\n \n2\n,\n\n\nlukeSkywalker\n,\n\n\nepisodeThree\n:\n \n3\n,\n\n\nmayTheFourth\n:\n \n4\n,\n\n\nanakinSkywalker\n,\n\n\n};\n\n\n\n// good\n\n\nconst\n \nobj\n \n=\n \n{\n\n\nlukeSkywalker\n,\n\n\nanakinSkywalker\n,\n\n\nepisodeOne\n:\n \n1\n,\n\n\ntwoJediWalkIntoACantina\n:\n \n2\n,\n\n\nepisodeThree\n:\n \n3\n,\n\n\nmayTheFourth\n:\n \n4\n,\n\n\n};\n\n\n\n\n\n\n\n\n3.6\n Only quote properties that are invalid identifiers. eslint: \nquote-props\n jscs: \ndisallowQuotedKeysInObjects\n\n\n\n\n\n\nWhy? In general we consider it subjectively easier to read. It improves syntax highlighting, and is also more easily optimized by many JS engines.\n\n\n\n\n// bad\n\n\nconst\n \nbad\n \n=\n \n{\n\n\nfoo\n:\n \n3\n,\n\n\nbar\n:\n \n4\n,\n\n\ndata-blah\n:\n \n5\n,\n\n\n};\n\n\n\n// good\n\n\nconst\n \ngood\n \n=\n \n{\n\n\nfoo\n:\n \n3\n,\n\n\nbar\n:\n \n4\n,\n\n\ndata-blah\n:\n \n5\n,\n\n\n};\n\n\n\n\n\n\n\n\n3.7\n Do not call \nObject.prototype\n methods directly, such as \nhasOwnProperty\n, \npropertyIsEnumerable\n, and \nisPrototypeOf\n.\n\n\n\n\n\n\nWhy? These methods may be shadowed by properties on the object in question - consider \n{ hasOwnProperty: false }\n - or, the object may be a null object (\nObject.create(null)\n).\n\n\n\n\n// bad\n\n\nconsole\n.\nlog\n(\nobject\n.\nhasOwnProperty\n(\nkey\n));\n\n\n\n// good\n\n\nconsole\n.\nlog\n(\nObject\n.\nprototype\n.\nhasOwnProperty\n.\ncall\n(\nobject\n,\n \nkey\n));\n\n\n\n// best\n\n\nconst\n \nhas\n \n=\n \nObject\n.\nprototype\n.\nhasOwnProperty\n;\n \n// cache the lookup once, in module scope.\n\n\n/* or */\n\n\nimport\n \nhas\n \nfrom\n \nhas\n;\n\n\n// ...\n\n\nconsole\n.\nlog\n(\nhas\n.\ncall\n(\nobject\n,\n \nkey\n));\n\n\n\n\n\n\n\n\n3.8\n Prefer the object spread operator over \nObject.assign\n to shallow-copy objects. Use the object rest operator to get a new object with certain properties omitted.\n\n\n\n\n// very bad\n\n\nconst\n \noriginal\n \n=\n \n{\n \na\n:\n \n1\n,\n \nb\n:\n \n2\n \n};\n\n\nconst\n \ncopy\n \n=\n \nObject\n.\nassign\n(\noriginal\n,\n \n{\n \nc\n:\n \n3\n \n});\n \n// this mutates `original` \u0ca0_\u0ca0\n\n\ndelete\n \ncopy\n.\na\n;\n \n// so does this\n\n\n\n// bad\n\n\nconst\n \noriginal\n \n=\n \n{\n \na\n:\n \n1\n,\n \nb\n:\n \n2\n \n};\n\n\nconst\n \ncopy\n \n=\n \nObject\n.\nassign\n({},\n \noriginal\n,\n \n{\n \nc\n:\n \n3\n \n});\n \n// copy =\n { a: 1, b: 2, c: 3 }\n\n\n\n// good\n\n\nconst\n \noriginal\n \n=\n \n{\n \na\n:\n \n1\n,\n \nb\n:\n \n2\n \n};\n\n\nconst\n \ncopy\n \n=\n \n{\n \n...\noriginal\n,\n \nc\n:\n \n3\n \n};\n \n// copy =\n { a: 1, b: 2, c: 3 }\n\n\n\nconst\n \n{\n \na\n,\n \n...\nnoA\n \n}\n \n=\n \ncopy\n;\n \n// noA =\n { b: 2, c: 3 }\n\n\n\n\n\n\n\u2b06 back to top\n\n\nArrays\n\n\n\n\n\n\n4.1\n Use the literal syntax for array creation. eslint: \nno-array-constructor\n\n\n\n\n// bad\n\n\nconst\n \nitems\n \n=\n \nnew\n \nArray\n();\n\n\n\n// good\n\n\nconst\n \nitems\n \n=\n \n[];\n\n\n\n\n\n\n\n\n4.2\n Use \nArray#push\n instead of direct assignment to add items to an array.\n\n\n\n\nconst\n \nsomeStack\n \n=\n \n[];\n\n\n\n// bad\n\n\nsomeStack\n[\nsomeStack\n.\nlength\n]\n \n=\n \nabracadabra\n;\n\n\n\n// good\n\n\nsomeStack\n.\npush\n(\nabracadabra\n);\n\n\n\n\n\n\n\n\n4.3\n Use array spreads \n...\n to copy arrays.\n\n\n\n\n// bad\n\n\nconst\n \nlen\n \n=\n \nitems\n.\nlength\n;\n\n\nconst\n \nitemsCopy\n \n=\n \n[];\n\n\nlet\n \ni\n;\n\n\n\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n \nlen\n;\n \ni\n \n+=\n \n1\n)\n \n{\n\n\nitemsCopy\n[\ni\n]\n \n=\n \nitems\n[\ni\n];\n\n\n}\n\n\n\n// good\n\n\nconst\n \nitemsCopy\n \n=\n \n[...\nitems\n];\n\n\n\n\n\n\n\n\n4.4\n To convert an array-like object to an array, use \nArray.from\n.\n\n\n\n\nconst\n \nfoo\n \n=\n \ndocument\n.\nquerySelectorAll\n(\n.foo\n);\n\n\nconst\n \nnodes\n \n=\n \nArray\n.\nfrom\n(\nfoo\n);\n\n\n\n\n\n\n\n\n4.5\n Use return statements in array method callbacks. It's ok to omit the return if the function body consists of a single statement following \n8.2\n. eslint: \narray-callback-return\n\n\n\n\n// good\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\nmap\n((\nx\n)\n \n=\n \n{\n\n  \nconst\n \ny\n \n=\n \nx\n \n+\n \n1\n;\n\n  \nreturn\n \nx\n \n*\n \ny\n;\n\n\n});\n\n\n\n// good\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\nmap\n(\nx\n \n=\n \nx\n \n+\n \n1\n);\n\n\n\n// bad\n\n\nconst\n \nflat\n \n=\n \n{};\n\n\n[[\n0\n,\n \n1\n],\n \n[\n2\n,\n \n3\n],\n \n[\n4\n,\n \n5\n]].\nreduce\n((\nmemo\n,\n \nitem\n,\n \nindex\n)\n \n=\n \n{\n\n  \nconst\n \nflatten\n \n=\n \nmemo\n.\nconcat\n(\nitem\n);\n\n  \nflat\n[\nindex\n]\n \n=\n \nflatten\n;\n\n\n});\n\n\n\n// good\n\n\nconst\n \nflat\n \n=\n \n{};\n\n\n[[\n0\n,\n \n1\n],\n \n[\n2\n,\n \n3\n],\n \n[\n4\n,\n \n5\n]].\nreduce\n((\nmemo\n,\n \nitem\n,\n \nindex\n)\n \n=\n \n{\n\n  \nconst\n \nflatten\n \n=\n \nmemo\n.\nconcat\n(\nitem\n);\n\n  \nflat\n[\nindex\n]\n \n=\n \nflatten\n;\n\n  \nreturn\n \nflatten\n;\n\n\n});\n\n\n\n// bad\n\n\ninbox\n.\nfilter\n((\nmsg\n)\n \n=\n \n{\n\n  \nconst\n \n{\n \nsubject\n,\n \nauthor\n \n}\n \n=\n \nmsg\n;\n\n  \nif\n \n(\nsubject\n \n===\n \nMockingbird\n)\n \n{\n\n    \nreturn\n \nauthor\n \n===\n \nHarper Lee\n;\n\n  \n}\n \nelse\n \n{\n\n    \nreturn\n \nfalse\n;\n\n  \n}\n\n\n});\n\n\n\n// good\n\n\ninbox\n.\nfilter\n((\nmsg\n)\n \n=\n \n{\n\n  \nconst\n \n{\n \nsubject\n,\n \nauthor\n \n}\n \n=\n \nmsg\n;\n\n  \nif\n \n(\nsubject\n \n===\n \nMockingbird\n)\n \n{\n\n    \nreturn\n \nauthor\n \n===\n \nHarper Lee\n;\n\n  \n}\n\n\n  \nreturn\n \nfalse\n;\n\n\n});\n\n\n\n\n\n\n\u2b06 back to top\n\n\nDestructuring\n\n\n\n\n\n\n5.1\n Use object destructuring when accessing and using multiple properties of an object. jscs: \nrequireObjectDestructuring\n\n\n\n\n\n\nWhy? Destructuring saves you from creating temporary references for those properties.\n\n\n\n\n// bad\n\n\nfunction\n \ngetFullName\n(\nuser\n)\n \n{\n\n  \nconst\n \nfirstName\n \n=\n \nuser\n.\nfirstName\n;\n\n  \nconst\n \nlastName\n \n=\n \nuser\n.\nlastName\n;\n\n\n  \nreturn\n \n`\n${\nfirstName\n}\n \n${\nlastName\n}\n`\n;\n\n\n}\n\n\n\n// good\n\n\nfunction\n \ngetFullName\n(\nuser\n)\n \n{\n\n  \nconst\n \n{\n \nfirstName\n,\n \nlastName\n \n}\n \n=\n \nuser\n;\n\n  \nreturn\n \n`\n${\nfirstName\n}\n \n${\nlastName\n}\n`\n;\n\n\n}\n\n\n\n// best\n\n\nfunction\n \ngetFullName\n({\n \nfirstName\n,\n \nlastName\n \n})\n \n{\n\n  \nreturn\n \n`\n${\nfirstName\n}\n \n${\nlastName\n}\n`\n;\n\n\n}\n\n\n\n\n\n\n\n\n5.2\n Use array destructuring. jscs: \nrequireArrayDestructuring\n\n\n\n\nconst\n \narr\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n];\n\n\n\n// bad\n\n\nconst\n \nfirst\n \n=\n \narr\n[\n0\n];\n\n\nconst\n \nsecond\n \n=\n \narr\n[\n1\n];\n\n\n\n// good\n\n\nconst\n \n[\nfirst\n,\n \nsecond\n]\n \n=\n \narr\n;\n\n\n\n\n\n\n\n\n5.3\n Use object destructuring for multiple return values, not array destructuring. jscs: \ndisallowArrayDestructuringReturn\n\n\n\n\n\n\nWhy? You can add new properties over time or change the order of things without breaking call sites.\n\n\n\n\n// bad\n\n\nfunction\n \nprocessInput\n(\ninput\n)\n \n{\n\n  \n// then a miracle occurs\n\n  \nreturn\n \n[\nleft\n,\n \nright\n,\n \ntop\n,\n \nbottom\n];\n\n\n}\n\n\n\n// the caller needs to think about the order of return data\n\n\nconst\n \n[\nleft\n,\n \n__\n,\n \ntop\n]\n \n=\n \nprocessInput\n(\ninput\n);\n\n\n\n// good\n\n\nfunction\n \nprocessInput\n(\ninput\n)\n \n{\n\n  \n// then a miracle occurs\n\n  \nreturn\n \n{\n \nleft\n,\n \nright\n,\n \ntop\n,\n \nbottom\n \n};\n\n\n}\n\n\n\n// the caller selects only the data they need\n\n\nconst\n \n{\n \nleft\n,\n \ntop\n \n}\n \n=\n \nprocessInput\n(\ninput\n);\n\n\n\n\n\n\n\u2b06 back to top\n\n\nStrings\n\n\n\n\n\n\n6.1\n Use single quotes \n''\n for strings. eslint: \nquotes\n jscs: \nvalidateQuoteMarks\n\n\n\n\n// bad\n\n\nconst\n \nname\n \n=\n \nCapt. Janeway\n;\n\n\n\n// bad - template literals should contain interpolation or newlines\n\n\nconst\n \nname\n \n=\n \n`Capt. Janeway`\n;\n\n\n\n// good\n\n\nconst\n \nname\n \n=\n \nCapt. Janeway\n;\n\n\n\n\n\n\n\n\n6.2\n Strings that cause the line to go over 100 characters should not be written across multiple lines using string concatenation.\n\n\n\n\n\n\nWhy? Broken strings are painful to work with and make code less searchable.\n\n\n\n\n// bad\n\n\nconst\n \nerrorMessage\n \n=\n \nThis is a super long error that was thrown because \\\n\n\nof Batman. When you stop to think about how Batman had anything to do \\\n\n\nwith this, you would get nowhere \\\n\n\nfast.\n;\n\n\n\n// bad\n\n\nconst\n \nerrorMessage\n \n=\n \nThis is a super long error that was thrown because \n \n+\n\n  \nof Batman. When you stop to think about how Batman had anything to do \n \n+\n\n  \nwith this, you would get nowhere fast.\n;\n\n\n\n// good\n\n\nconst\n \nerrorMessage\n \n=\n \nThis is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.\n;\n\n\n\n\n\n\n\n\n6.3\n When programmatically building up strings, use template strings instead of concatenation. eslint: \nprefer-template\n \ntemplate-curly-spacing\n jscs: \nrequireTemplateStrings\n\n\n\n\n\n\nWhy? Template strings give you a readable, concise syntax with proper newlines and string interpolation features.\n\n\n\n\n// bad\n\n\nfunction\n \nsayHi\n(\nname\n)\n \n{\n\n  \nreturn\n \nHow are you, \n \n+\n \nname\n \n+\n \n?\n;\n\n\n}\n\n\n\n// bad\n\n\nfunction\n \nsayHi\n(\nname\n)\n \n{\n\n  \nreturn\n \n[\nHow are you, \n,\n \nname\n,\n \n?\n].\njoin\n();\n\n\n}\n\n\n\n// bad\n\n\nfunction\n \nsayHi\n(\nname\n)\n \n{\n\n  \nreturn\n \n`How are you, \n${\n \nname\n \n}\n?`\n;\n\n\n}\n\n\n\n// good\n\n\nfunction\n \nsayHi\n(\nname\n)\n \n{\n\n  \nreturn\n \n`How are you, \n${\nname\n}\n?`\n;\n\n\n}\n\n\n\n\n\n\n\n\n\n\n6.4\n Never use \neval()\n on a string, it opens too many vulnerabilities.\n\n\n\n\n\n\n6.5\n Do not unnecessarily escape characters in strings. eslint: \nno-useless-escape\n\n\n\n\n\n\n\n\nWhy? Backslashes harm readability, thus they should only be present when necessary.\n\n\n\n\n// bad\n\n\nconst\n \nfoo\n \n=\n \n\\\nthis\\\n \\i\\s \\\nquoted\\\n;\n\n\n\n// good\n\n\nconst\n \nfoo\n \n=\n \n\\\nthis\\\n is \nquoted\n;\n\n\nconst\n \nfoo\n \n=\n \n`my name is \n${\nname\n}\n`\n;\n\n\n\n\n\n\n\u2b06 back to top\n\n\nFunctions\n\n\n\n\n\n\n7.1\n Use named function expressions instead of function declarations. eslint: \nfunc-style\n jscs: \ndisallowFunctionDeclarations\n\n\n\n\n\n\nWhy? Function declarations are hoisted, which means that it\u2019s easy - too easy - to reference the function before it is defined in the file. This harms readability and maintainability. If you find that a function\u2019s definition is large or complex enough that it is interfering with understanding the rest of the file, then perhaps it\u2019s time to extract it to its own module! Don\u2019t forget to name the expression - anonymous functions can make it harder to locate the problem in an Error's call stack. (\nDiscussion\n)\n\n\n\n\n// bad\n\n\nfunction\n \nfoo\n()\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// bad\n\n\nconst\n \nfoo\n \n=\n \nfunction\n \n()\n \n{\n\n  \n// ...\n\n\n};\n\n\n\n// good\n\n\nconst\n \nfoo\n \n=\n \nfunction\n \nbar\n()\n \n{\n\n  \n// ...\n\n\n};\n\n\n\n\n\n\n\n\n7.2\n Wrap immediately invoked function expressions in parentheses. eslint: \nwrap-iife\n jscs: \nrequireParenthesesAroundIIFE\n\n\n\n\n\n\nWhy? An immediately invoked function expression is a single unit - wrapping both it, and its invocation parens, in parens, cleanly expresses this. Note that in a world with modules everywhere, you almost never need an IIFE.\n\n\n\n\n// immediately-invoked function expression (IIFE)\n\n\n(\nfunction\n \n()\n \n{\n\n  \nconsole\n.\nlog\n(\nWelcome to the Internet. Please follow me.\n);\n\n\n}());\n\n\n\n\n\n\n\n\n\n\n7.3\n Never declare a function in a non-function block (if, while, etc). Assign the function to a variable instead. Browsers will allow you to do it, but they all interpret it differently, which is bad news bears. eslint: \nno-loop-func\n\n\n\n\n\n\n7.4\n \nNote:\n ECMA-262 defines a \nblock\n as a list of statements. A function declaration is not a statement. \nRead ECMA-262's note on this issue\n.\n\n\n\n\n\n\n// bad\n\n\nif\n \n(\ncurrentUser\n)\n \n{\n\n  \nfunction\n \ntest\n()\n \n{\n\n    \nconsole\n.\nlog\n(\nNope.\n);\n\n  \n}\n\n\n}\n\n\n\n// good\n\n\nlet\n \ntest\n;\n\n\nif\n \n(\ncurrentUser\n)\n \n{\n\n  \ntest\n \n=\n \n()\n \n=\n \n{\n\n    \nconsole\n.\nlog\n(\nYup.\n);\n\n  \n};\n\n\n}\n\n\n\n\n\n\n\n\n7.5\n Never name a parameter \narguments\n. This will take precedence over the \narguments\n object that is given to every function scope.\n\n\n\n\n// bad\n\n\nfunction\n \nfoo\n(\nname\n,\n \noptions\n,\n \narguments\n)\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// good\n\n\nfunction\n \nfoo\n(\nname\n,\n \noptions\n,\n \nargs\n)\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n\n\n\n\n\n7.6\n Never use \narguments\n, opt to use rest syntax \n...\n instead. eslint: \nprefer-rest-params\n\n\n\n\n\n\nWhy? \n...\n is explicit about which arguments you want pulled. Plus, rest arguments are a real Array, and not merely Array-like like \narguments\n.\n\n\n\n\n// bad\n\n\nfunction\n \nconcatenateAll\n()\n \n{\n\n  \nconst\n \nargs\n \n=\n \nArray\n.\nprototype\n.\nslice\n.\ncall\n(\narguments\n);\n\n  \nreturn\n \nargs\n.\njoin\n(\n);\n\n\n}\n\n\n\n// good\n\n\nfunction\n \nconcatenateAll\n(...\nargs\n)\n \n{\n\n  \nreturn\n \nargs\n.\njoin\n(\n);\n\n\n}\n\n\n\n\n\n\n\n\n7.7\n Use default parameter syntax rather than mutating function arguments.\n\n\n\n\n// really bad\n\n\nfunction\n \nhandleThings\n(\nopts\n)\n \n{\n\n  \n// No! We shouldn\nt mutate function arguments.\n\n  \n// Double bad: if opts is falsy it\nll be set to an object which may\n\n  \n// be what you want but it can introduce subtle bugs.\n\n  \nopts\n \n=\n \nopts\n \n||\n \n{};\n\n  \n// ...\n\n\n}\n\n\n\n// still bad\n\n\nfunction\n \nhandleThings\n(\nopts\n)\n \n{\n\n  \nif\n \n(\nopts\n \n===\n \nvoid\n \n0\n)\n \n{\n\n    \nopts\n \n=\n \n{};\n\n  \n}\n\n  \n// ...\n\n\n}\n\n\n\n// good\n\n\nfunction\n \nhandleThings\n(\nopts\n \n=\n \n{})\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n\n\n\n\n\n7.8\n Avoid side effects with default parameters.\n\n\n\n\n\n\nWhy? They are confusing to reason about.\n\n\n\n\nvar\n \nb\n \n=\n \n1\n;\n\n\n// bad\n\n\nfunction\n \ncount\n(\na\n \n=\n \nb\n++\n)\n \n{\n\n  \nconsole\n.\nlog\n(\na\n);\n\n\n}\n\n\ncount\n();\n  \n// 1\n\n\ncount\n();\n  \n// 2\n\n\ncount\n(\n3\n);\n \n// 3\n\n\ncount\n();\n  \n// 3\n\n\n\n\n\n\n\n\n7.9\n Always put default parameters last.\n\n\n\n\n// bad\n\n\nfunction\n \nhandleThings\n(\nopts\n \n=\n \n{},\n \nname\n)\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// good\n\n\nfunction\n \nhandleThings\n(\nname\n,\n \nopts\n \n=\n \n{})\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n\n\n\n\n\n7.10\n Never use the Function constructor to create a new function. eslint: \nno-new-func\n\n\n\n\n\n\nWhy? Creating a function in this way evaluates a string similarly to eval(), which opens vulnerabilities.\n\n\n\n\n// bad\n\n\nvar\n \nadd\n \n=\n \nnew\n \nFunction\n(\na\n,\n \nb\n,\n \nreturn a + b\n);\n\n\n\n// still bad\n\n\nvar\n \nsubtract\n \n=\n \nFunction\n(\na\n,\n \nb\n,\n \nreturn a - b\n);\n\n\n\n\n\n\n\n\n7.11\n Spacing in a function signature. eslint: \nspace-before-function-paren\n \nspace-before-blocks\n\n\n\n\n\n\nWhy? Consistency is good, and you shouldn\u2019t have to add or remove a space when adding or removing a name.\n\n\n\n\n// bad\n\n\nconst\n \nf\n \n=\n \nfunction\n(){};\n\n\nconst\n \ng\n \n=\n \nfunction\n \n(){};\n\n\nconst\n \nh\n \n=\n \nfunction\n()\n \n{};\n\n\n\n// good\n\n\nconst\n \nx\n \n=\n \nfunction\n \n()\n \n{};\n\n\nconst\n \ny\n \n=\n \nfunction\n \na\n()\n \n{};\n\n\n\n\n\n\n\n\n7.12\n Never mutate parameters. eslint: \nno-param-reassign\n\n\n\n\n\n\nWhy? Manipulating objects passed in as parameters can cause unwanted variable side effects in the original caller.\n\n\n\n\n// bad\n\n\nfunction\n \nf1\n(\nobj\n)\n \n{\n\n  \nobj\n.\nkey\n \n=\n \n1\n;\n\n\n}\n\n\n\n// good\n\n\nfunction\n \nf2\n(\nobj\n)\n \n{\n\n  \nconst\n \nkey\n \n=\n \nObject\n.\nprototype\n.\nhasOwnProperty\n.\ncall\n(\nobj\n,\n \nkey\n)\n \n?\n \nobj\n.\nkey\n \n:\n \n1\n;\n\n\n}\n\n\n\n\n\n\n\n\n7.13\n Never reassign parameters. eslint: \nno-param-reassign\n\n\n\n\n\n\nWhy? Reassigning parameters can lead to unexpected behavior, especially when accessing the \narguments\n object. It can also cause optimization issues, especially in V8.\n\n\n\n\n// bad\n\n\nfunction\n \nf1\n(\na\n)\n \n{\n\n  \na\n \n=\n \n1\n;\n\n  \n// ...\n\n\n}\n\n\n\nfunction\n \nf2\n(\na\n)\n \n{\n\n  \nif\n \n(\n!\na\n)\n \n{\n \na\n \n=\n \n1\n;\n \n}\n\n  \n// ...\n\n\n}\n\n\n\n// good\n\n\nfunction\n \nf3\n(\na\n)\n \n{\n\n  \nconst\n \nb\n \n=\n \na\n \n||\n \n1\n;\n\n  \n// ...\n\n\n}\n\n\n\nfunction\n \nf4\n(\na\n \n=\n \n1\n)\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n\n\n\n\n\n7.14\n Prefer the use of the spread operator \n...\n to call variadic functions. eslint: \nprefer-spread\n\n\n\n\n\n\nWhy? It's cleaner, you don't need to supply a context, and you can not easily compose \nnew\n with \napply\n.\n\n\n\n\n// bad\n\n\nconst\n \nx\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n];\n\n\nconsole\n.\nlog\n.\napply\n(\nconsole\n,\n \nx\n);\n\n\n\n// good\n\n\nconst\n \nx\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n];\n\n\nconsole\n.\nlog\n(...\nx\n);\n\n\n\n// bad\n\n\nnew\n \n(\nFunction\n.\nprototype\n.\nbind\n.\napply\n(\nDate\n,\n \n[\nnull\n,\n \n2016\n,\n \n8\n,\n \n5\n]));\n\n\n\n// good\n\n\nnew\n \nDate\n(...[\n2016\n,\n \n8\n,\n \n5\n]);\n\n\n\n\n\n\n\n\n7.15\n Functions with multiline signatures, or invocations, should be indented just like every other multiline list in this guide: with each item on a line by itself, with a trailing comma on the last item.\n\n\n\n\n// bad\n\n\nfunction\n \nfoo\n(\nbar\n,\n\n             \nbaz\n,\n\n             \nquux\n)\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// good\n\n\nfunction\n \nfoo\n(\n\n  \nbar\n,\n\n  \nbaz\n,\n\n  \nquux\n,\n\n\n)\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// bad\n\n\nconsole\n.\nlog\n(\nfoo\n,\n\n  \nbar\n,\n\n  \nbaz\n);\n\n\n\n// good\n\n\nconsole\n.\nlog\n(\n\n  \nfoo\n,\n\n  \nbar\n,\n\n  \nbaz\n,\n\n\n);\n\n\n\n\n\n\n\u2b06 back to top\n\n\nArrow Functions\n\n\n\n\n\n\n8.1\n When you must use function expressions (as when passing an anonymous function), use arrow function notation. eslint: \nprefer-arrow-callback\n, \narrow-spacing\n jscs: \nrequireArrowFunctions\n\n\n\n\n\n\nWhy? It creates a version of the function that executes in the context of \nthis\n, which is usually what you want, and is a more concise syntax.\n\n\nWhy not? If you have a fairly complicated function, you might move that logic out into its own function declaration.\n\n\n\n\n// bad\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\nmap\n(\nfunction\n \n(\nx\n)\n \n{\n\n  \nconst\n \ny\n \n=\n \nx\n \n+\n \n1\n;\n\n  \nreturn\n \nx\n \n*\n \ny\n;\n\n\n});\n\n\n\n// good\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\nmap\n((\nx\n)\n \n=\n \n{\n\n  \nconst\n \ny\n \n=\n \nx\n \n+\n \n1\n;\n\n  \nreturn\n \nx\n \n*\n \ny\n;\n\n\n});\n\n\n\n\n\n\n\n\n8.2\n If the function body consists of a single expression, omit the braces and use the implicit return. Otherwise, keep the braces and use a \nreturn\n statement. eslint: \narrow-parens\n, \narrow-body-style\n jscs:  \ndisallowParenthesesAroundArrowParam\n, \nrequireShorthandArrowFunctions\n\n\n\n\n\n\nWhy? Syntactic sugar. It reads well when multiple functions are chained together.\n\n\n\n\n// bad\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\nmap\n(\nnumber\n \n=\n \n{\n\n  \nconst\n \nnextNumber\n \n=\n \nnumber\n \n+\n \n1\n;\n\n  \n`A string containing the \n${\nnextNumber\n}\n.`\n;\n\n\n});\n\n\n\n// good\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\nmap\n(\nnumber\n \n=\n \n`A string containing the \n${\nnumber\n}\n.`\n);\n\n\n\n// good\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\nmap\n((\nnumber\n)\n \n=\n \n{\n\n  \nconst\n \nnextNumber\n \n=\n \nnumber\n \n+\n \n1\n;\n\n  \nreturn\n \n`A string containing the \n${\nnextNumber\n}\n.`\n;\n\n\n});\n\n\n\n// good\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\nmap\n((\nnumber\n,\n \nindex\n)\n \n=\n \n({\n\n  \n[\nindex\n]\n:\n \nnumber\n,\n\n\n}));\n\n\n\n\n\n\n\n\n8.3\n In case the expression spans over multiple lines, wrap it in parentheses for better readability.\n\n\n\n\n\n\nWhy? It shows clearly where the function starts and ends.\n\n\n\n\n// bad\n\n\n[\nget\n,\n \npost\n,\n \nput\n].\nmap\n(\nhttpMethod\n \n=\n \nObject\n.\nprototype\n.\nhasOwnProperty\n.\ncall\n(\n\n    \nhttpMagicObjectWithAVeryLongName\n,\n\n    \nhttpMethod\n,\n\n  \n)\n\n\n);\n\n\n\n// good\n\n\n[\nget\n,\n \npost\n,\n \nput\n].\nmap\n(\nhttpMethod\n \n=\n \n(\n\n  \nObject\n.\nprototype\n.\nhasOwnProperty\n.\ncall\n(\n\n    \nhttpMagicObjectWithAVeryLongName\n,\n\n    \nhttpMethod\n,\n\n  \n)\n\n\n));\n\n\n\n\n\n\n\n\n8.4\n If your function takes a single argument and doesn\u2019t use braces, omit the parentheses. Otherwise, always include parentheses around arguments. eslint: \narrow-parens\n jscs:  \ndisallowParenthesesAroundArrowParam\n\n\n\n\n\n\nWhy? Less visual clutter.\n\n\n\n\n// bad\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\nmap\n((\nx\n)\n \n=\n \nx\n \n*\n \nx\n);\n\n\n\n// good\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\nmap\n(\nx\n \n=\n \nx\n \n*\n \nx\n);\n\n\n\n// good\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\nmap\n(\nnumber\n \n=\n \n(\n\n  \n`A long string with the \n${\nnumber\n}\n. It\u2019s so long that we don\u2019t want it to take up space on the .map line!`\n\n\n));\n\n\n\n// bad\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\nmap\n(\nx\n \n=\n \n{\n\n  \nconst\n \ny\n \n=\n \nx\n \n+\n \n1\n;\n\n  \nreturn\n \nx\n \n*\n \ny\n;\n\n\n});\n\n\n\n// good\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\nmap\n((\nx\n)\n \n=\n \n{\n\n  \nconst\n \ny\n \n=\n \nx\n \n+\n \n1\n;\n\n  \nreturn\n \nx\n \n*\n \ny\n;\n\n\n});\n\n\n\n\n\n\n\n\n8.5\n Avoid confusing arrow function syntax (\n=\n) with comparison operators (\n=\n, \n=\n). eslint: \nno-confusing-arrow\n\n\n\n\n// bad\n\n\nconst\n \nitemHeight\n \n=\n \nitem\n \n=\n \nitem\n.\nheight\n \n \n256\n \n?\n \nitem\n.\nlargeSize\n \n:\n \nitem\n.\nsmallSize\n;\n\n\n\n// bad\n\n\nconst\n \nitemHeight\n \n=\n \n(\nitem\n)\n \n=\n \nitem\n.\nheight\n \n \n256\n \n?\n \nitem\n.\nlargeSize\n \n:\n \nitem\n.\nsmallSize\n;\n\n\n\n// good\n\n\nconst\n \nitemHeight\n \n=\n \nitem\n \n=\n \n(\nitem\n.\nheight\n \n \n256\n \n?\n \nitem\n.\nlargeSize\n \n:\n \nitem\n.\nsmallSize\n);\n\n\n\n// good\n\n\nconst\n \nitemHeight\n \n=\n \n(\nitem\n)\n \n=\n \n{\n\n  \nconst\n \n{\n \nheight\n,\n \nlargeSize\n,\n \nsmallSize\n \n}\n \n=\n \nitem\n;\n\n  \nreturn\n \nheight\n \n \n256\n \n?\n \nlargeSize\n \n:\n \nsmallSize\n;\n\n\n};\n\n\n\n\n\n\n\u2b06 back to top\n\n\nClasses \n Constructors\n\n\n\n\n\n\n9.1\n Always use \nclass\n. Avoid manipulating \nprototype\n directly.\n\n\n\n\n\n\nWhy? \nclass\n syntax is more concise and easier to reason about.\n\n\n\n\n// bad\n\n\nfunction\n \nQueue\n(\ncontents\n \n=\n \n[])\n \n{\n\n  \nthis\n.\nqueue\n \n=\n \n[...\ncontents\n];\n\n\n}\n\n\nQueue\n.\nprototype\n.\npop\n \n=\n \nfunction\n \n()\n \n{\n\n  \nconst\n \nvalue\n \n=\n \nthis\n.\nqueue\n[\n0\n];\n\n  \nthis\n.\nqueue\n.\nsplice\n(\n0\n,\n \n1\n);\n\n  \nreturn\n \nvalue\n;\n\n\n};\n\n\n\n\n// good\n\n\nclass\n \nQueue\n \n{\n\n  \nconstructor\n(\ncontents\n \n=\n \n[])\n \n{\n\n    \nthis\n.\nqueue\n \n=\n \n[...\ncontents\n];\n\n  \n}\n\n  \npop\n()\n \n{\n\n    \nconst\n \nvalue\n \n=\n \nthis\n.\nqueue\n[\n0\n];\n\n    \nthis\n.\nqueue\n.\nsplice\n(\n0\n,\n \n1\n);\n\n    \nreturn\n \nvalue\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n9.2\n Use \nextends\n for inheritance.\n\n\n\n\n\n\nWhy? It is a built-in way to inherit prototype functionality without breaking \ninstanceof\n.\n\n\n\n\n// bad\n\n\nconst\n \ninherits\n \n=\n \nrequire\n(\ninherits\n);\n\n\nfunction\n \nPeekableQueue\n(\ncontents\n)\n \n{\n\n  \nQueue\n.\napply\n(\nthis\n,\n \ncontents\n);\n\n\n}\n\n\ninherits\n(\nPeekableQueue\n,\n \nQueue\n);\n\n\nPeekableQueue\n.\nprototype\n.\npeek\n \n=\n \nfunction\n \n()\n \n{\n\n  \nreturn\n \nthis\n.\nqueue\n[\n0\n];\n\n\n};\n\n\n\n// good\n\n\nclass\n \nPeekableQueue\n \nextends\n \nQueue\n \n{\n\n  \npeek\n()\n \n{\n\n    \nreturn\n \nthis\n.\nqueue\n[\n0\n];\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n9.3\n Methods can return \nthis\n to help with method chaining.\n\n\n\n\n// bad\n\n\nJedi\n.\nprototype\n.\njump\n \n=\n \nfunction\n \n()\n \n{\n\n  \nthis\n.\njumping\n \n=\n \ntrue\n;\n\n  \nreturn\n \ntrue\n;\n\n\n};\n\n\n\nJedi\n.\nprototype\n.\nsetHeight\n \n=\n \nfunction\n \n(\nheight\n)\n \n{\n\n  \nthis\n.\nheight\n \n=\n \nheight\n;\n\n\n};\n\n\n\nconst\n \nluke\n \n=\n \nnew\n \nJedi\n();\n\n\nluke\n.\njump\n();\n \n// =\n true\n\n\nluke\n.\nsetHeight\n(\n20\n);\n \n// =\n undefined\n\n\n\n// good\n\n\nclass\n \nJedi\n \n{\n\n  \njump\n()\n \n{\n\n    \nthis\n.\njumping\n \n=\n \ntrue\n;\n\n    \nreturn\n \nthis\n;\n\n  \n}\n\n\n  \nsetHeight\n(\nheight\n)\n \n{\n\n    \nthis\n.\nheight\n \n=\n \nheight\n;\n\n    \nreturn\n \nthis\n;\n\n  \n}\n\n\n}\n\n\n\nconst\n \nluke\n \n=\n \nnew\n \nJedi\n();\n\n\n\nluke\n.\njump\n()\n\n  \n.\nsetHeight\n(\n20\n);\n\n\n\n\n\n\n\n\n9.4\n It's okay to write a custom toString() method, just make sure it works successfully and causes no side effects.\n\n\n\n\nclass\n \nJedi\n \n{\n\n  \nconstructor\n(\noptions\n \n=\n \n{})\n \n{\n\n    \nthis\n.\nname\n \n=\n \noptions\n.\nname\n \n||\n \nno name\n;\n\n  \n}\n\n\n  \ngetName\n()\n \n{\n\n    \nreturn\n \nthis\n.\nname\n;\n\n  \n}\n\n\n  \ntoString\n()\n \n{\n\n    \nreturn\n \n`Jedi - \n${\nthis\n.\ngetName\n()\n}\n`\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n9.5\n Classes have a default constructor if one is not specified. An empty constructor function or one that just delegates to a parent class is unnecessary. eslint: \nno-useless-constructor\n\n\n\n\n// bad\n\n\nclass\n \nJedi\n \n{\n\n  \nconstructor\n()\n \n{}\n\n\n  \ngetName\n()\n \n{\n\n    \nreturn\n \nthis\n.\nname\n;\n\n  \n}\n\n\n}\n\n\n\n// bad\n\n\nclass\n \nRey\n \nextends\n \nJedi\n \n{\n\n  \nconstructor\n(...\nargs\n)\n \n{\n\n    \nsuper\n(...\nargs\n);\n\n  \n}\n\n\n}\n\n\n\n// good\n\n\nclass\n \nRey\n \nextends\n \nJedi\n \n{\n\n  \nconstructor\n(...\nargs\n)\n \n{\n\n    \nsuper\n(...\nargs\n);\n\n    \nthis\n.\nname\n \n=\n \nRey\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n9.6\n Avoid duplicate class members. eslint: \nno-dupe-class-members\n\n\n\n\n\n\nWhy? Duplicate class member declarations will silently prefer the last one - having duplicates is almost certainly a bug.\n\n\n\n\n// bad\n\n\nclass\n \nFoo\n \n{\n\n  \nbar\n()\n \n{\n \nreturn\n \n1\n;\n \n}\n\n  \nbar\n()\n \n{\n \nreturn\n \n2\n;\n \n}\n\n\n}\n\n\n\n// good\n\n\nclass\n \nFoo\n \n{\n\n  \nbar\n()\n \n{\n \nreturn\n \n1\n;\n \n}\n\n\n}\n\n\n\n// good\n\n\nclass\n \nFoo\n \n{\n\n  \nbar\n()\n \n{\n \nreturn\n \n2\n;\n \n}\n\n\n}\n\n\n\n\n\n\n\u2b06 back to top\n\n\nModules\n\n\n\n\n\n\n10.1\n Always use modules (\nimport\n/\nexport\n) over a non-standard module system. You can always transpile to your preferred module system.\n\n\n\n\n\n\nWhy? Modules are the future, let's start using the future now.\n\n\n\n\n// bad\n\n\nconst\n \nAirbnbStyleGuide\n \n=\n \nrequire\n(\n./AirbnbStyleGuide\n);\n\n\nmodule\n.\nexports\n \n=\n \nAirbnbStyleGuide\n.\nes6\n;\n\n\n\n// ok\n\n\nimport\n \nAirbnbStyleGuide\n \nfrom\n \n./AirbnbStyleGuide\n;\n\n\nexport\n \ndefault\n \nAirbnbStyleGuide\n.\nes6\n;\n\n\n\n// best\n\n\nimport\n \n{\n \nes6\n \n}\n \nfrom\n \n./AirbnbStyleGuide\n;\n\n\nexport\n \ndefault\n \nes6\n;\n\n\n\n\n\n\n\n\n10.2\n Do not use wildcard imports.\n\n\n\n\n\n\nWhy? This makes sure you have a single default export.\n\n\n\n\n// bad\n\n\nimport\n \n*\n \nas\n \nAirbnbStyleGuide\n \nfrom\n \n./AirbnbStyleGuide\n;\n\n\n\n// good\n\n\nimport\n \nAirbnbStyleGuide\n \nfrom\n \n./AirbnbStyleGuide\n;\n\n\n\n\n\n\n\n\n10.3\n And do not export directly from an import.\n\n\n\n\n\n\nWhy? Although the one-liner is concise, having one clear way to import and one clear way to export makes things consistent.\n\n\n\n\n// bad\n\n\n// filename es6.js\n\n\nexport\n \n{\n \nes6\n \nas\n \ndefault\n \n}\n \nfrom\n \n./AirbnbStyleGuide\n;\n\n\n\n// good\n\n\n// filename es6.js\n\n\nimport\n \n{\n \nes6\n \n}\n \nfrom\n \n./AirbnbStyleGuide\n;\n\n\nexport\n \ndefault\n \nes6\n;\n\n\n\n\n\n\n\n\n10.4\n Only import from a path in one place.\neslint: \nno-duplicate-imports\n\n\nWhy? Having multiple lines that import from the same path can make code harder to maintain.\n\n\n\n\n\n\n\n\n// bad\n\n\nimport\n \nfoo\n \nfrom\n \nfoo\n;\n\n\n// \u2026 some other imports \u2026 //\n\n\nimport\n \n{\n \nnamed1\n,\n \nnamed2\n \n}\n \nfrom\n \nfoo\n;\n\n\n\n// good\n\n\nimport\n \nfoo\n,\n \n{\n \nnamed1\n,\n \nnamed2\n \n}\n \nfrom\n \nfoo\n;\n\n\n\n// good\n\n\nimport\n \nfoo\n,\n \n{\n\n  \nnamed1\n,\n\n  \nnamed2\n,\n\n\n}\n \nfrom\n \nfoo\n;\n\n\n\n\n\n\n\n\n10.5\n Do not export mutable bindings.\neslint: \nimport/no-mutable-exports\n\n\nWhy? Mutation should be avoided in general, but in particular when exporting mutable bindings. While this technique may be needed for some special cases, in general, only constant references should be exported.\n\n\n\n\n\n\n\n\n// bad\n\n\nlet\n \nfoo\n \n=\n \n3\n;\n\n\nexport\n \n{\n \nfoo\n \n};\n\n\n\n// good\n\n\nconst\n \nfoo\n \n=\n \n3\n;\n\n\nexport\n \n{\n \nfoo\n \n};\n\n\n\n\n\n\n\n\n10.6\n In modules with a single export, prefer default export over named export.\neslint: \nimport/prefer-default-export\n\n\n\n\n// bad\n\n\nexport\n \nfunction\n \nfoo\n()\n \n{}\n\n\n\n// good\n\n\nexport\n \ndefault\n \nfunction\n \nfoo\n()\n \n{}\n\n\n\n\n\n\n\n\n10.7\n Put all \nimport\ns above non-import statements.\neslint: \nimport/first\n\n\nWhy? Since \nimport\ns are hoisted, keeping them all at the top prevents surprising behavior.\n\n\n\n\n\n\n\n\n// bad\n\n\nimport\n \nfoo\n \nfrom\n \nfoo\n;\n\n\nfoo\n.\ninit\n();\n\n\n\nimport\n \nbar\n \nfrom\n \nbar\n;\n\n\n\n// good\n\n\nimport\n \nfoo\n \nfrom\n \nfoo\n;\n\n\nimport\n \nbar\n \nfrom\n \nbar\n;\n\n\n\nfoo\n.\ninit\n();\n\n\n\n\n\n\n\n\n10.8\n Multiline imports should be indented just like multiline array and object literals.\n\n\n\n\n\n\nWhy? The curly braces follow the same indentation rules as every other curly brace block in the style guide, as do the trailing commas.\n\n\n\n\n// bad\n\n\nimport\n \n{\nlongNameA\n,\n \nlongNameB\n,\n \nlongNameC\n,\n \nlongNameD\n,\n \nlongNameE\n}\n \nfrom\n \npath\n;\n\n\n\n// good\n\n\nimport\n \n{\n\n  \nlongNameA\n,\n\n  \nlongNameB\n,\n\n  \nlongNameC\n,\n\n  \nlongNameD\n,\n\n  \nlongNameE\n,\n\n\n}\n \nfrom\n \npath\n;\n\n\n\n\n\n\n\n\n10.9\n Disallow Webpack loader syntax in module import statements.\neslint: \nimport/no-webpack-loader-syntax\n\n\nWhy? Since using Webpack syntax in the imports couples the code to a module bundler. Prefer using the loader syntax in \nwebpack.config.js\n.\n\n\n\n\n\n\n\n\n// bad\n\n\nimport\n \nfooSass\n \nfrom\n \ncss!sass!foo.scss\n;\n\n\nimport\n \nbarCss\n \nfrom\n \nstyle!css!bar.css\n;\n\n\n\n// good\n\n\nimport\n \nfooSass\n \nfrom\n \nfoo.scss\n;\n\n\nimport\n \nbarCss\n \nfrom\n \nbar.css\n;\n\n\n\n\n\n\n\u2b06 back to top\n\n\nIterators and Generators\n\n\n\n\n\n\n11.1\n Don't use iterators. Prefer JavaScript's higher-order functions instead of loops like \nfor-in\n or \nfor-of\n. eslint: \nno-iterator\n \nno-restricted-syntax\n\n\n\n\n\n\nWhy? This enforces our immutable rule. Dealing with pure functions that return values is easier to reason about than side effects.\n\n\nUse \nmap()\n / \nevery()\n / \nfilter()\n / \nfind()\n / \nfindIndex()\n / \nreduce()\n / \nsome()\n / ... to iterate over arrays, and \nObject.keys()\n / \nObject.values()\n / \nObject.entries()\n to produce arrays so you can iterate over objects.\n\n\n\n\nconst\n \nnumbers\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n];\n\n\n\n// bad\n\n\nlet\n \nsum\n \n=\n \n0\n;\n\n\nfor\n \n(\nlet\n \nnum\n \nof\n \nnumbers\n)\n \n{\n\n  \nsum\n \n+=\n \nnum\n;\n\n\n}\n\n\nsum\n \n===\n \n15\n;\n\n\n\n// good\n\n\nlet\n \nsum\n \n=\n \n0\n;\n\n\nnumbers\n.\nforEach\n(\nnum\n \n=\n \nsum\n \n+=\n \nnum\n);\n\n\nsum\n \n===\n \n15\n;\n\n\n\n// best (use the functional force)\n\n\nconst\n \nsum\n \n=\n \nnumbers\n.\nreduce\n((\ntotal\n,\n \nnum\n)\n \n=\n \ntotal\n \n+\n \nnum\n,\n \n0\n);\n\n\nsum\n \n===\n \n15\n;\n\n\n\n// bad\n\n\nconst\n \nincreasedByOne\n \n=\n \n[];\n\n\nfor\n \n(\nlet\n \ni\n \n=\n \n0\n;\n \ni\n \n \nnumbers\n.\nlength\n;\n \ni\n++\n)\n \n{\n\n  \nincreasedByOne\n.\npush\n(\nnumbers\n[\ni\n]\n \n+\n \n1\n);\n\n\n}\n\n\n\n// good\n\n\nconst\n \nincreasedByOne\n \n=\n \n[];\n\n\nnumbers\n.\nforEach\n(\nnum\n \n=\n \nincreasedByOne\n.\npush\n(\nnum\n \n+\n \n1\n));\n\n\n\n// best (keeping it functional)\n\n\nconst\n \nincreasedByOne\n \n=\n \nnumbers\n.\nmap\n(\nnum\n \n=\n \nnum\n \n+\n \n1\n);\n\n\n\n\n\n\n\n\n11.2\n Don't use generators for now.\n\n\n\n\n\n\nWhy? They don't transpile well to ES5.\n\n\n\n\n\n\n11.3\n If you must use generators, or if you disregard \nour advice\n, make sure their function signature is spaced properly. eslint: \ngenerator-star-spacing\n\n\n\n\n\n\nWhy? \nfunction\n and \n*\n are part of the same conceptual keyword - \n*\n is not a modifier for \nfunction\n, \nfunction*\n is a unique construct, different from \nfunction\n.\n\n\n\n\n// bad\n\n\nfunction\n \n*\n \nfoo\n()\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// bad\n\n\nconst\n \nbar\n \n=\n \nfunction\n \n*\n \n()\n \n{\n\n  \n// ...\n\n\n};\n\n\n\n// bad\n\n\nconst\n \nbaz\n \n=\n \nfunction\n \n*\n()\n \n{\n\n  \n// ...\n\n\n};\n\n\n\n// bad\n\n\nconst\n \nquux\n \n=\n \nfunction\n*\n()\n \n{\n\n  \n// ...\n\n\n};\n\n\n\n// bad\n\n\nfunction\n*\nfoo\n()\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// bad\n\n\nfunction\n \n*\nfoo\n()\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// very bad\n\n\nfunction\n\n\n*\n\n\nfoo\n()\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// very bad\n\n\nconst\n \nwat\n \n=\n \nfunction\n\n\n*\n\n\n()\n \n{\n\n  \n// ...\n\n\n};\n\n\n\n// good\n\n\nfunction\n*\n \nfoo\n()\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// good\n\n\nconst\n \nfoo\n \n=\n \nfunction\n*\n \n()\n \n{\n\n  \n// ...\n\n\n};\n\n\n\n\n\n\n\u2b06 back to top\n\n\nProperties\n\n\n\n\n\n\n12.1\n Use dot notation when accessing properties. eslint: \ndot-notation\n jscs: \nrequireDotNotation\n\n\n\n\nconst\n \nluke\n \n=\n \n{\n\n  \njedi\n:\n \ntrue\n,\n\n  \nage\n:\n \n28\n,\n\n\n};\n\n\n\n// bad\n\n\nconst\n \nisJedi\n \n=\n \nluke\n[\njedi\n];\n\n\n\n// good\n\n\nconst\n \nisJedi\n \n=\n \nluke\n.\njedi\n;\n\n\n\n\n\n\n\n\n12.2\n Use bracket notation \n[]\n when accessing properties with a variable.\n\n\n\n\nconst\n \nluke\n \n=\n \n{\n\n  \njedi\n:\n \ntrue\n,\n\n  \nage\n:\n \n28\n,\n\n\n};\n\n\n\nfunction\n \ngetProp\n(\nprop\n)\n \n{\n\n  \nreturn\n \nluke\n[\nprop\n];\n\n\n}\n\n\n\nconst\n \nisJedi\n \n=\n \ngetProp\n(\njedi\n);\n\n\n\n\n\n\n\u2b06 back to top\n\n\nVariables\n\n\n\n\n\n\n13.1\n Always use \nconst\n to declare variables. Not doing so will result in global variables. We want to avoid polluting the global namespace. Captain Planet warned us of that. eslint: \nno-undef\n \nprefer-const\n\n\n\n\n// bad\n\n\nsuperPower\n \n=\n \nnew\n \nSuperPower\n();\n\n\n\n// good\n\n\nconst\n \nsuperPower\n \n=\n \nnew\n \nSuperPower\n();\n\n\n\n\n\n\n\n\n13.2\n Use one \nconst\n declaration per variable. eslint: \none-var\n jscs: \ndisallowMultipleVarDecl\n\n\n\n\n\n\nWhy? It's easier to add new variable declarations this way, and you never have to worry about swapping out a \n;\n for a \n,\n or introducing punctuation-only diffs. You can also step through each declaration with the debugger, instead of jumping through all of them at once.\n\n\n\n\n// bad\n\n\nconst\n \nitems\n \n=\n \ngetItems\n(),\n\n    \ngoSportsTeam\n \n=\n \ntrue\n,\n\n    \ndragonball\n \n=\n \nz\n;\n\n\n\n// bad\n\n\n// (compare to above, and try to spot the mistake)\n\n\nconst\n \nitems\n \n=\n \ngetItems\n(),\n\n    \ngoSportsTeam\n \n=\n \ntrue\n;\n\n    \ndragonball\n \n=\n \nz\n;\n\n\n\n// good\n\n\nconst\n \nitems\n \n=\n \ngetItems\n();\n\n\nconst\n \ngoSportsTeam\n \n=\n \ntrue\n;\n\n\nconst\n \ndragonball\n \n=\n \nz\n;\n\n\n\n\n\n\n\n\n13.3\n Group all your \nconst\ns and then group all your \nlet\ns.\n\n\n\n\n\n\nWhy? This is helpful when later on you might need to assign a variable depending on one of the previous assigned variables.\n\n\n\n\n// bad\n\n\nlet\n \ni\n,\n \nlen\n,\n \ndragonball\n,\n\n    \nitems\n \n=\n \ngetItems\n(),\n\n    \ngoSportsTeam\n \n=\n \ntrue\n;\n\n\n\n// bad\n\n\nlet\n \ni\n;\n\n\nconst\n \nitems\n \n=\n \ngetItems\n();\n\n\nlet\n \ndragonball\n;\n\n\nconst\n \ngoSportsTeam\n \n=\n \ntrue\n;\n\n\nlet\n \nlen\n;\n\n\n\n// good\n\n\nconst\n \ngoSportsTeam\n \n=\n \ntrue\n;\n\n\nconst\n \nitems\n \n=\n \ngetItems\n();\n\n\nlet\n \ndragonball\n;\n\n\nlet\n \ni\n;\n\n\nlet\n \nlength\n;\n\n\n\n\n\n\n\n\n13.4\n Assign variables where you need them, but place them in a reasonable place.\n\n\n\n\n\n\nWhy? \nlet\n and \nconst\n are block scoped and not function scoped.\n\n\n\n\n// bad - unnecessary function call\n\n\nfunction\n \ncheckName\n(\nhasName\n)\n \n{\n\n  \nconst\n \nname\n \n=\n \ngetName\n();\n\n\n  \nif\n \n(\nhasName\n \n===\n \ntest\n)\n \n{\n\n    \nreturn\n \nfalse\n;\n\n  \n}\n\n\n  \nif\n \n(\nname\n \n===\n \ntest\n)\n \n{\n\n    \nthis\n.\nsetName\n(\n);\n\n    \nreturn\n \nfalse\n;\n\n  \n}\n\n\n  \nreturn\n \nname\n;\n\n\n}\n\n\n\n// good\n\n\nfunction\n \ncheckName\n(\nhasName\n)\n \n{\n\n  \nif\n \n(\nhasName\n \n===\n \ntest\n)\n \n{\n\n    \nreturn\n \nfalse\n;\n\n  \n}\n\n\n  \nconst\n \nname\n \n=\n \ngetName\n();\n\n\n  \nif\n \n(\nname\n \n===\n \ntest\n)\n \n{\n\n    \nthis\n.\nsetName\n(\n);\n\n    \nreturn\n \nfalse\n;\n\n  \n}\n\n\n  \nreturn\n \nname\n;\n\n\n}\n\n\n\n\n\n\n\n\nDon't chain variable assignments.\n\n\nChaining variable assignments creates implicit global variables.\n\n\n\n\n// bad\n\n\n(\nfunction\n \nexample\n()\n \n{\n\n  \n// JavaScript interprets this as\n\n  \n// let a = ( b = ( c = 1 ) );\n\n  \n// The let keyword only applies to variable a; variables b and c become\n\n  \n// global variables.\n\n  \nlet\n \na\n \n=\n \nb\n \n=\n \nc\n \n=\n \n1\n;\n\n\n}());\n\n\n\nconsole\n.\nlog\n(\na\n);\n \n// undefined\n\n\nconsole\n.\nlog\n(\nb\n);\n \n// 1\n\n\nconsole\n.\nlog\n(\nc\n);\n \n// 1\n\n\n\n// good\n\n\n(\nfunction\n \nexample\n()\n \n{\n\n  \nlet\n \na\n \n=\n \n1\n;\n\n  \nlet\n \nb\n \n=\n \na\n;\n\n  \nlet\n \nc\n \n=\n \na\n;\n\n\n}());\n\n\n\nconsole\n.\nlog\n(\na\n);\n \n// undefined\n\n\nconsole\n.\nlog\n(\nb\n);\n \n// undefined\n\n\nconsole\n.\nlog\n(\nc\n);\n \n// undefined\n\n\n\n// the same applies for `const`\n\n\n\n\n\n\n\n\n13.6\n Avoid using unary increments and decrements (++, --). eslint \nno-plusplus\n\n\n\n\n\n\nWhy? Per the eslint documentation, unary increment and decrement statements are subject to automatic semicolon insertion and can cause silent errors with incrementing or decrementing values within an application. It is also more expressive to mutate your values with statements like \nnum += 1\n instead of \nnum++\n or \nnum ++\n. Disallowing unary increment and decrement statements also prevents you from pre-incrementing/pre-decrementing values unintentionally which can also cause unexpected behavior in your programs.\n\n\n\n\n// bad\n\n\n\nlet\n \narray\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n];\n\n\nlet\n \nnum\n \n=\n \n1\n;\n\n\nnum\n++\n;\n\n\n--\nnum\n;\n\n\n\nlet\n \nsum\n \n=\n \n0\n;\n\n\nlet\n \ntruthyCount\n \n=\n \n0\n;\n\n\nfor\n \n(\nlet\n \ni\n \n=\n \n0\n;\n \ni\n \n \narray\n.\nlength\n;\n \ni\n++\n)\n \n{\n\n  \nlet\n \nvalue\n \n=\n \narray\n[\ni\n];\n\n  \nsum\n \n+=\n \nvalue\n;\n\n  \nif\n \n(\nvalue\n)\n \n{\n\n    \ntruthyCount\n++\n;\n\n  \n}\n\n\n}\n\n\n\n// good\n\n\n\nlet\n \narray\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n];\n\n\nlet\n \nnum\n \n=\n \n1\n;\n\n\nnum\n \n+=\n \n1\n;\n\n\nnum\n \n-=\n \n1\n;\n\n\n\nconst\n \nsum\n \n=\n \narray\n.\nreduce\n((\na\n,\n \nb\n)\n \n=\n \na\n \n+\n \nb\n,\n \n0\n);\n\n\nconst\n \ntruthyCount\n \n=\n \narray\n.\nfilter\n(\nBoolean\n).\nlength\n;\n\n\n\n\n\n\n\u2b06 back to top\n\n\nHoisting\n\n\n\n\n\n\n14.1\n \nvar\n declarations get hoisted to the top of their scope, their assignment does not. \nconst\n and \nlet\n declarations are blessed with a new concept called \nTemporal Dead Zones (TDZ)\n. It's important to know why \ntypeof is no longer safe\n.\n\n\n\n\n// we know this wouldn\nt work (assuming there\n\n\n// is no notDefined global variable)\n\n\nfunction\n \nexample\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nnotDefined\n);\n \n// =\n throws a ReferenceError\n\n\n}\n\n\n\n// creating a variable declaration after you\n\n\n// reference the variable will work due to\n\n\n// variable hoisting. Note: the assignment\n\n\n// value of `true` is not hoisted.\n\n\nfunction\n \nexample\n()\n \n{\n\n  \nconsole\n.\nlog\n(\ndeclaredButNotAssigned\n);\n \n// =\n undefined\n\n  \nvar\n \ndeclaredButNotAssigned\n \n=\n \ntrue\n;\n\n\n}\n\n\n\n// the interpreter is hoisting the variable\n\n\n// declaration to the top of the scope,\n\n\n// which means our example could be rewritten as:\n\n\nfunction\n \nexample\n()\n \n{\n\n  \nlet\n \ndeclaredButNotAssigned\n;\n\n  \nconsole\n.\nlog\n(\ndeclaredButNotAssigned\n);\n \n// =\n undefined\n\n  \ndeclaredButNotAssigned\n \n=\n \ntrue\n;\n\n\n}\n\n\n\n// using const and let\n\n\nfunction\n \nexample\n()\n \n{\n\n  \nconsole\n.\nlog\n(\ndeclaredButNotAssigned\n);\n \n// =\n throws a ReferenceError\n\n  \nconsole\n.\nlog\n(\ntypeof\n \ndeclaredButNotAssigned\n);\n \n// =\n throws a ReferenceError\n\n  \nconst\n \ndeclaredButNotAssigned\n \n=\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\n\n\n14.2\n Anonymous function expressions hoist their variable name, but not the function assignment.\n\n\n\n\nfunction\n \nexample\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nanonymous\n);\n \n// =\n undefined\n\n\n  \nanonymous\n();\n \n// =\n TypeError anonymous is not a function\n\n\n  \nvar\n \nanonymous\n \n=\n \nfunction\n \n()\n \n{\n\n    \nconsole\n.\nlog\n(\nanonymous function expression\n);\n\n  \n};\n\n\n}\n\n\n\n\n\n\n\n\n14.3\n Named function expressions hoist the variable name, not the function name or the function body.\n\n\n\n\nfunction\n \nexample\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nnamed\n);\n \n// =\n undefined\n\n\n  \nnamed\n();\n \n// =\n TypeError named is not a function\n\n\n  \nsuperPower\n();\n \n// =\n ReferenceError superPower is not defined\n\n\n  \nvar\n \nnamed\n \n=\n \nfunction\n \nsuperPower\n()\n \n{\n\n    \nconsole\n.\nlog\n(\nFlying\n);\n\n  \n};\n\n\n}\n\n\n\n// the same is true when the function name\n\n\n// is the same as the variable name.\n\n\nfunction\n \nexample\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nnamed\n);\n \n// =\n undefined\n\n\n  \nnamed\n();\n \n// =\n TypeError named is not a function\n\n\n  \nvar\n \nnamed\n \n=\n \nfunction\n \nnamed\n()\n \n{\n\n    \nconsole\n.\nlog\n(\nnamed\n);\n\n  \n};\n\n\n}\n\n\n\n\n\n\n\n\n14.4\n Function declarations hoist their name and the function body.\n\n\n\n\nfunction\n \nexample\n()\n \n{\n\n  \nsuperPower\n();\n \n// =\n Flying\n\n\n  \nfunction\n \nsuperPower\n()\n \n{\n\n    \nconsole\n.\nlog\n(\nFlying\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\nFor more information refer to \nJavaScript Scoping \n Hoisting\n by \nBen Cherry\n.\n\n\n\n\n\u2b06 back to top\n\n\nComparison Operators \n Equality\n\n\n\n\n\n\n\n\n15.1\n Use \n===\n and \n!==\n over \n==\n and \n!=\n. eslint: \neqeqeq\n\n\n\n\n\n\n15.2\n Conditional statements such as the \nif\n statement evaluate their expression using coercion with the \nToBoolean\n abstract method and always follow these simple rules:\n\n\n\n\n\n\nObjects\n evaluate to \ntrue\n\n\n\n\nUndefined\n evaluates to \nfalse\n\n\nNull\n evaluates to \nfalse\n\n\nBooleans\n evaluate to \nthe value of the boolean\n\n\nNumbers\n evaluate to \nfalse\n if \n+0, -0, or NaN\n, otherwise \ntrue\n\n\nStrings\n evaluate to \nfalse\n if an empty string \n''\n, otherwise \ntrue\n\n\n\n\nif\n \n([\n0\n]\n \n \n[])\n \n{\n\n  \n// true\n\n  \n// an array (even an empty one) is an object, objects will evaluate to true\n\n\n}\n\n\n\n\n\n\n\n\n15.3\n Use shortcuts for booleans, but explicit comparisons for strings and numbers.\n\n\n\n\n// bad\n\n\nif\n \n(\nisValid\n \n===\n \ntrue\n)\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// good\n\n\nif\n \n(\nisValid\n)\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// bad\n\n\nif\n \n(\nname\n)\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// good\n\n\nif\n \n(\nname\n \n!==\n \n)\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// bad\n\n\nif\n \n(\ncollection\n.\nlength\n)\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// good\n\n\nif\n \n(\ncollection\n.\nlength\n \n \n0\n)\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n\n\n\n\n\n\n\n15.4\n For more information see \nTruth Equality and JavaScript\n by Angus Croll.\n\n\n\n\n\n\n15.5\n Use braces to create blocks in \ncase\n and \ndefault\n clauses that contain lexical declarations (e.g. \nlet\n, \nconst\n, \nfunction\n, and \nclass\n).\n\n\n\n\n\n\n\n\nWhy? Lexical declarations are visible in the entire \nswitch\n block but only get initialized when assigned, which only happens when its \ncase\n is reached. This causes problems when multiple \ncase\n clauses attempt to define the same thing.\n\n\n\n\neslint rules: \nno-case-declarations\n.\n\n\n// bad\n\n\nswitch\n \n(\nfoo\n)\n \n{\n\n  \ncase\n \n1\n:\n\n    \nlet\n \nx\n \n=\n \n1\n;\n\n    \nbreak\n;\n\n  \ncase\n \n2\n:\n\n    \nconst\n \ny\n \n=\n \n2\n;\n\n    \nbreak\n;\n\n  \ncase\n \n3\n:\n\n    \nfunction\n \nf\n()\n \n{\n\n      \n// ...\n\n    \n}\n\n    \nbreak\n;\n\n  \ndefault\n:\n\n    \nclass\n \nC\n \n{}\n\n\n}\n\n\n\n// good\n\n\nswitch\n \n(\nfoo\n)\n \n{\n\n  \ncase\n \n1\n:\n \n{\n\n    \nlet\n \nx\n \n=\n \n1\n;\n\n    \nbreak\n;\n\n  \n}\n\n  \ncase\n \n2\n:\n \n{\n\n    \nconst\n \ny\n \n=\n \n2\n;\n\n    \nbreak\n;\n\n  \n}\n\n  \ncase\n \n3\n:\n \n{\n\n    \nfunction\n \nf\n()\n \n{\n\n      \n// ...\n\n    \n}\n\n    \nbreak\n;\n\n  \n}\n\n  \ncase\n \n4\n:\n\n    \nbar\n();\n\n    \nbreak\n;\n\n  \ndefault\n:\n \n{\n\n    \nclass\n \nC\n \n{}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n15.6\n Ternaries should not be nested and generally be single line expressions.\n\n\n\n\neslint rules: \nno-nested-ternary\n.\n\n\n// bad\n\n\nconst\n \nfoo\n \n=\n \nmaybe1\n \n \nmaybe2\n\n  \n?\n \nbar\n\n  \n:\n \nvalue1\n \n \nvalue2\n \n?\n \nbaz\n \n:\n \nnull\n;\n\n\n\n// better\n\n\nconst\n \nmaybeNull\n \n=\n \nvalue1\n \n \nvalue2\n \n?\n \nbaz\n \n:\n \nnull\n;\n\n\n\nconst\n \nfoo\n \n=\n \nmaybe1\n \n \nmaybe2\n\n  \n?\n \nbar\n\n  \n:\n \nmaybeNull\n;\n\n\n\n// best\n\n\nconst\n \nmaybeNull\n \n=\n \nvalue1\n \n \nvalue2\n \n?\n \nbaz\n \n:\n \nnull\n;\n\n\n\nconst\n \nfoo\n \n=\n \nmaybe1\n \n \nmaybe2\n \n?\n \nbar\n \n:\n \nmaybeNull\n;\n\n\n\n\n\n\n\n\n15.7\n Avoid unneeded ternary statements.\n\n\n\n\neslint rules: \nno-unneeded-ternary\n.\n\n\n// bad\n\n\nconst\n \nfoo\n \n=\n \na\n \n?\n \na\n \n:\n \nb\n;\n\n\nconst\n \nbar\n \n=\n \nc\n \n?\n \ntrue\n \n:\n \nfalse\n;\n\n\nconst\n \nbaz\n \n=\n \nc\n \n?\n \nfalse\n \n:\n \ntrue\n;\n\n\n\n// good\n\n\nconst\n \nfoo\n \n=\n \na\n \n||\n \nb\n;\n\n\nconst\n \nbar\n \n=\n \n!!\nc\n;\n\n\nconst\n \nbaz\n \n=\n \n!\nc\n;\n\n\n\n\n\n\n\u2b06 back to top\n\n\nBlocks\n\n\n\n\n\n\n16.1\n Use braces with all multi-line blocks.\n\n\n\n\n// bad\n\n\nif\n \n(\ntest\n)\n\n  \nreturn\n \nfalse\n;\n\n\n\n// good\n\n\nif\n \n(\ntest\n)\n \nreturn\n \nfalse\n;\n\n\n\n// good\n\n\nif\n \n(\ntest\n)\n \n{\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n// bad\n\n\nfunction\n \nfoo\n()\n \n{\n \nreturn\n \nfalse\n;\n \n}\n\n\n\n// good\n\n\nfunction\n \nbar\n()\n \n{\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n\n\n\n\n\n16.2\n If you're using multi-line blocks with \nif\n and \nelse\n, put \nelse\n on the same line as your \nif\n block's closing brace. eslint: \nbrace-style\n jscs:  \ndisallowNewlineBeforeBlockStatements\n\n\n\n\n// bad\n\n\nif\n \n(\ntest\n)\n \n{\n\n  \nthing1\n();\n\n  \nthing2\n();\n\n\n}\n\n\nelse\n \n{\n\n  \nthing3\n();\n\n\n}\n\n\n\n// good\n\n\nif\n \n(\ntest\n)\n \n{\n\n  \nthing1\n();\n\n  \nthing2\n();\n\n\n}\n \nelse\n \n{\n\n  \nthing3\n();\n\n\n}\n\n\n\n\n\n\n\u2b06 back to top\n\n\nComments\n\n\n\n\n\n\n17.1\n Use \n/** ... */\n for multi-line comments.\n\n\n\n\n// bad\n\n\n// make() returns a new element\n\n\n// based on the passed in tag name\n\n\n//\n\n\n// @param {String} tag\n\n\n// @return {Element} element\n\n\nfunction\n \nmake\n(\ntag\n)\n \n{\n\n\n  \n// ...\n\n\n  \nreturn\n \nelement\n;\n\n\n}\n\n\n\n// good\n\n\n/**\n\n\n * make() returns a new element\n\n\n * based on the passed-in tag name\n\n\n */\n\n\nfunction\n \nmake\n(\ntag\n)\n \n{\n\n\n  \n// ...\n\n\n  \nreturn\n \nelement\n;\n\n\n}\n\n\n\n\n\n\n\n\n17.2\n Use \n//\n for single line comments. Place single line comments on a newline above the subject of the comment. Put an empty line before the comment unless it's on the first line of a block.\n\n\n\n\n// bad\n\n\nconst\n \nactive\n \n=\n \ntrue\n;\n  \n// is current tab\n\n\n\n// good\n\n\n// is current tab\n\n\nconst\n \nactive\n \n=\n \ntrue\n;\n\n\n\n// bad\n\n\nfunction\n \ngetType\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nfetching type...\n);\n\n  \n// set the default type to \nno type\n\n  \nconst\n \ntype\n \n=\n \nthis\n.\ntype\n \n||\n \nno type\n;\n\n\n  \nreturn\n \ntype\n;\n\n\n}\n\n\n\n// good\n\n\nfunction\n \ngetType\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nfetching type...\n);\n\n\n  \n// set the default type to \nno type\n\n  \nconst\n \ntype\n \n=\n \nthis\n.\ntype\n \n||\n \nno type\n;\n\n\n  \nreturn\n \ntype\n;\n\n\n}\n\n\n\n// also good\n\n\nfunction\n \ngetType\n()\n \n{\n\n  \n// set the default type to \nno type\n\n  \nconst\n \ntype\n \n=\n \nthis\n.\ntype\n \n||\n \nno type\n;\n\n\n  \nreturn\n \ntype\n;\n\n\n}\n\n\n\n\n\n\n\n\n17.3\n Start all comments with a space to make it easier to read. eslint: \nspaced-comment\n\n\n\n\n// bad\n\n\n//is current tab\n\n\nconst\n \nactive\n \n=\n \ntrue\n;\n\n\n\n// good\n\n\n// is current tab\n\n\nconst\n \nactive\n \n=\n \ntrue\n;\n\n\n\n// bad\n\n\n/**\n\n\n *make() returns a new element\n\n\n *based on the passed-in tag name\n\n\n */\n\n\nfunction\n \nmake\n(\ntag\n)\n \n{\n\n\n  \n// ...\n\n\n  \nreturn\n \nelement\n;\n\n\n}\n\n\n\n// good\n\n\n/**\n\n\n * make() returns a new element\n\n\n * based on the passed-in tag name\n\n\n */\n\n\nfunction\n \nmake\n(\ntag\n)\n \n{\n\n\n  \n// ...\n\n\n  \nreturn\n \nelement\n;\n\n\n}\n\n\n\n\n\n\n\n\n\n\n17.4\n Prefixing your comments with \nFIXME\n or \nTODO\n helps other developers quickly understand if you're pointing out a problem that needs to be revisited, or if you're suggesting a solution to the problem that needs to be implemented. These are different than regular comments because they are actionable. The actions are \nFIXME: -- need to figure this out\n or \nTODO: -- need to implement\n.\n\n\n\n\n\n\n17.5\n Use \n// FIXME:\n to annotate problems.\n\n\n\n\n\n\nclass\n \nCalculator\n \nextends\n \nAbacus\n \n{\n\n  \nconstructor\n()\n \n{\n\n    \nsuper\n();\n\n\n    \n// FIXME: shouldn\nt use a global here\n\n    \ntotal\n \n=\n \n0\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n17.6\n Use \n// TODO:\n to annotate solutions to problems.\n\n\n\n\nclass\n \nCalculator\n \nextends\n \nAbacus\n \n{\n\n  \nconstructor\n()\n \n{\n\n    \nsuper\n();\n\n\n    \n// TODO: total should be configurable by an options param\n\n    \nthis\n.\ntotal\n \n=\n \n0\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\u2b06 back to top\n\n\nWhitespace\n\n\n\n\n\n\n18.1\n Use soft tabs set to 2 spaces. eslint: \nindent\n jscs: \nvalidateIndentation\n\n\n\n\n// bad\n\n\nfunction\n \nfoo\n()\n \n{\n\n\n\u2219\u2219\u2219\u2219\nlet\n \nname\n;\n\n\n}\n\n\n\n// bad\n\n\nfunction\n \nbar\n()\n \n{\n\n\n\u2219\nlet\n \nname\n;\n\n\n}\n\n\n\n// good\n\n\nfunction\n \nbaz\n()\n \n{\n\n\n\u2219\u2219\nlet\n \nname\n;\n\n\n}\n\n\n\n\n\n\n\n\n18.2\n Place 1 space before the leading brace. eslint: \nspace-before-blocks\n jscs: \nrequireSpaceBeforeBlockStatements\n\n\n\n\n// bad\n\n\nfunction\n \ntest\n(){\n\n  \nconsole\n.\nlog\n(\ntest\n);\n\n\n}\n\n\n\n// good\n\n\nfunction\n \ntest\n()\n \n{\n\n  \nconsole\n.\nlog\n(\ntest\n);\n\n\n}\n\n\n\n// bad\n\n\ndog\n.\nset\n(\nattr\n,{\n\n  \nage\n:\n \n1 year\n,\n\n  \nbreed\n:\n \nBernese Mountain Dog\n,\n\n\n});\n\n\n\n// good\n\n\ndog\n.\nset\n(\nattr\n,\n \n{\n\n  \nage\n:\n \n1 year\n,\n\n  \nbreed\n:\n \nBernese Mountain Dog\n,\n\n\n});\n\n\n\n\n\n\n\n\n18.3\n Place 1 space before the opening parenthesis in control statements (\nif\n, \nwhile\n etc.). Place no space between the argument list and the function name in function calls and declarations. eslint: \nkeyword-spacing\n jscs: \nrequireSpaceAfterKeywords\n\n\n\n\n// bad\n\n\nif\n(\nisJedi\n)\n \n{\n\n  \nfight\n \n();\n\n\n}\n\n\n\n// good\n\n\nif\n \n(\nisJedi\n)\n \n{\n\n  \nfight\n();\n\n\n}\n\n\n\n// bad\n\n\nfunction\n \nfight\n \n()\n \n{\n\n  \nconsole\n.\nlog\n \n(\nSwooosh!\n);\n\n\n}\n\n\n\n// good\n\n\nfunction\n \nfight\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nSwooosh!\n);\n\n\n}\n\n\n\n\n\n\n\n\n18.4\n Set off operators with spaces. eslint: \nspace-infix-ops\n jscs: \nrequireSpaceBeforeBinaryOperators\n, \nrequireSpaceAfterBinaryOperators\n\n\n\n\n// bad\n\n\nconst\n \nx\n=\ny\n+\n5\n;\n\n\n\n// good\n\n\nconst\n \nx\n \n=\n \ny\n \n+\n \n5\n;\n\n\n\n\n\n\n\n\n18.5\n End files with a single newline character. eslint: \neol-last\n\n\n\n\n// bad\n\n\nimport\n \n{\n \nes6\n \n}\n \nfrom\n \n./AirbnbStyleGuide\n;\n\n  \n// ...\n\n\nexport\n \ndefault\n \nes6\n;\n\n\n\n\n\n\n// bad\n\n\nimport\n \n{\n \nes6\n \n}\n \nfrom\n \n./AirbnbStyleGuide\n;\n\n  \n// ...\n\n\nexport\n \ndefault\n \nes6\n;\n\u21b5\n\n\n\u21b5\n\n\n\n\n\n\n// good\n\n\nimport\n \n{\n \nes6\n \n}\n \nfrom\n \n./AirbnbStyleGuide\n;\n\n  \n// ...\n\n\nexport\n \ndefault\n \nes6\n;\n\u21b5\n\n\n\n\n\n\n\n\n18.6\n Use indentation when making long method chains (more than 2 method chains). Use a leading dot, which\nemphasizes that the line is a method call, not a new statement. eslint: \nnewline-per-chained-call\n \nno-whitespace-before-property\n\n\n\n\n// bad\n\n\n$\n(\n#items\n).\nfind\n(\n.selected\n).\nhighlight\n().\nend\n().\nfind\n(\n.open\n).\nupdateCount\n();\n\n\n\n// bad\n\n\n$\n(\n#items\n).\n\n  \nfind\n(\n.selected\n).\n\n    \nhighlight\n().\n\n    \nend\n().\n\n  \nfind\n(\n.open\n).\n\n    \nupdateCount\n();\n\n\n\n// good\n\n\n$\n(\n#items\n)\n\n  \n.\nfind\n(\n.selected\n)\n\n    \n.\nhighlight\n()\n\n    \n.\nend\n()\n\n  \n.\nfind\n(\n.open\n)\n\n    \n.\nupdateCount\n();\n\n\n\n// bad\n\n\nconst\n \nleds\n \n=\n \nstage\n.\nselectAll\n(\n.led\n).\ndata\n(\ndata\n).\nenter\n().\nappend\n(\nsvg:svg\n).\nclassed\n(\nled\n,\n \ntrue\n)\n\n    \n.\nattr\n(\nwidth\n,\n \n(\nradius\n \n+\n \nmargin\n)\n \n*\n \n2\n).\nappend\n(\nsvg:g\n)\n\n    \n.\nattr\n(\ntransform\n,\n \n`translate(\n${\nradius\n \n+\n \nmargin\n}\n,\n${\nradius\n \n+\n \nmargin\n}\n)`\n)\n\n    \n.\ncall\n(\ntron\n.\nled\n);\n\n\n\n// good\n\n\nconst\n \nleds\n \n=\n \nstage\n.\nselectAll\n(\n.led\n)\n\n    \n.\ndata\n(\ndata\n)\n\n  \n.\nenter\n().\nappend\n(\nsvg:svg\n)\n\n    \n.\nclassed\n(\nled\n,\n \ntrue\n)\n\n    \n.\nattr\n(\nwidth\n,\n \n(\nradius\n \n+\n \nmargin\n)\n \n*\n \n2\n)\n\n  \n.\nappend\n(\nsvg:g\n)\n\n    \n.\nattr\n(\ntransform\n,\n \n`translate(\n${\nradius\n \n+\n \nmargin\n}\n,\n${\nradius\n \n+\n \nmargin\n}\n)`\n)\n\n    \n.\ncall\n(\ntron\n.\nled\n);\n\n\n\n// good\n\n\nconst\n \nleds\n \n=\n \nstage\n.\nselectAll\n(\n.led\n).\ndata\n(\ndata\n);\n\n\n\n\n\n\n\n\n18.7\n Leave a blank line after blocks and before the next statement. jscs: \nrequirePaddingNewLinesAfterBlocks\n\n\n\n\n// bad\n\n\nif\n \n(\nfoo\n)\n \n{\n\n  \nreturn\n \nbar\n;\n\n\n}\n\n\nreturn\n \nbaz\n;\n\n\n\n// good\n\n\nif\n \n(\nfoo\n)\n \n{\n\n  \nreturn\n \nbar\n;\n\n\n}\n\n\n\nreturn\n \nbaz\n;\n\n\n\n// bad\n\n\nconst\n \nobj\n \n=\n \n{\n\n  \nfoo\n()\n \n{\n\n  \n},\n\n  \nbar\n()\n \n{\n\n  \n},\n\n\n};\n\n\nreturn\n \nobj\n;\n\n\n\n// good\n\n\nconst\n \nobj\n \n=\n \n{\n\n  \nfoo\n()\n \n{\n\n  \n},\n\n\n  \nbar\n()\n \n{\n\n  \n},\n\n\n};\n\n\n\nreturn\n \nobj\n;\n\n\n\n// bad\n\n\nconst\n \narr\n \n=\n \n[\n\n  \nfunction\n \nfoo\n()\n \n{\n\n  \n},\n\n  \nfunction\n \nbar\n()\n \n{\n\n  \n},\n\n\n];\n\n\nreturn\n \narr\n;\n\n\n\n// good\n\n\nconst\n \narr\n \n=\n \n[\n\n  \nfunction\n \nfoo\n()\n \n{\n\n  \n},\n\n\n  \nfunction\n \nbar\n()\n \n{\n\n  \n},\n\n\n];\n\n\n\nreturn\n \narr\n;\n\n\n\n\n\n\n\n\n18.8\n Do not pad your blocks with blank lines. eslint: \npadded-blocks\n jscs:  \ndisallowPaddingNewlinesInBlocks\n\n\n\n\n// bad\n\n\nfunction\n \nbar\n()\n \n{\n\n\n  \nconsole\n.\nlog\n(\nfoo\n);\n\n\n\n}\n\n\n\n// also bad\n\n\nif\n \n(\nbaz\n)\n \n{\n\n\n  \nconsole\n.\nlog\n(\nqux\n);\n\n\n}\n \nelse\n \n{\n\n  \nconsole\n.\nlog\n(\nfoo\n);\n\n\n\n}\n\n\n\n// good\n\n\nfunction\n \nbar\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nfoo\n);\n\n\n}\n\n\n\n// good\n\n\nif\n \n(\nbaz\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nqux\n);\n\n\n}\n \nelse\n \n{\n\n  \nconsole\n.\nlog\n(\nfoo\n);\n\n\n}\n\n\n\n\n\n\n\n\n18.9\n Do not add spaces inside parentheses. eslint: \nspace-in-parens\n jscs: \ndisallowSpacesInsideParentheses\n\n\n\n\n// bad\n\n\nfunction\n \nbar\n(\n \nfoo\n \n)\n \n{\n\n  \nreturn\n \nfoo\n;\n\n\n}\n\n\n\n// good\n\n\nfunction\n \nbar\n(\nfoo\n)\n \n{\n\n  \nreturn\n \nfoo\n;\n\n\n}\n\n\n\n// bad\n\n\nif\n \n(\n \nfoo\n \n)\n \n{\n\n  \nconsole\n.\nlog\n(\nfoo\n);\n\n\n}\n\n\n\n// good\n\n\nif\n \n(\nfoo\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nfoo\n);\n\n\n}\n\n\n\n\n\n\n\n\n18.10\n Do not add spaces inside brackets. eslint: \narray-bracket-spacing\n jscs: \ndisallowSpacesInsideArrayBrackets\n\n\n\n\n// bad\n\n\nconst\n \nfoo\n \n=\n \n[\n \n1\n,\n \n2\n,\n \n3\n \n];\n\n\nconsole\n.\nlog\n(\nfoo\n[\n \n0\n \n]);\n\n\n\n// good\n\n\nconst\n \nfoo\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n];\n\n\nconsole\n.\nlog\n(\nfoo\n[\n0\n]);\n\n\n\n\n\n\n\n\n18.11\n Add spaces inside curly braces. eslint: \nobject-curly-spacing\n jscs: \nrequireSpacesInsideObjectBrackets\n\n\n\n\n// bad\n\n\nconst\n \nfoo\n \n=\n \n{\nclark\n:\n \nkent\n};\n\n\n\n// good\n\n\nconst\n \nfoo\n \n=\n \n{\n \nclark\n:\n \nkent\n \n};\n\n\n\n\n\n\n\n\n18.12\n Avoid having lines of code that are longer than 100 characters (including whitespace). Note: per \nabove\n, long strings are exempt from this rule, and should not be broken up. eslint: \nmax-len\n jscs: \nmaximumLineLength\n\n\n\n\n\n\nWhy? This ensures readability and maintainability.\n\n\n\n\n// bad\n\n\nconst\n \nfoo\n \n=\n \njsonData\n \n \njsonData\n.\nfoo\n \n \njsonData\n.\nfoo\n.\nbar\n \n \njsonData\n.\nfoo\n.\nbar\n.\nbaz\n \n \njsonData\n.\nfoo\n.\nbar\n.\nbaz\n.\nquux\n \n \njsonData\n.\nfoo\n.\nbar\n.\nbaz\n.\nquux\n.\nxyzzy\n;\n\n\n\n// bad\n\n\n$\n.\najax\n({\n \nmethod\n:\n \nPOST\n,\n \nurl\n:\n \nhttps://airbnb.com/\n,\n \ndata\n:\n \n{\n \nname\n:\n \nJohn\n \n}\n \n}).\ndone\n(()\n \n=\n \nconsole\n.\nlog\n(\nCongratulations!\n)).\nfail\n(()\n \n=\n \nconsole\n.\nlog\n(\nYou have failed this city.\n));\n\n\n\n// good\n\n\nconst\n \nfoo\n \n=\n \njsonData\n\n  \n \njsonData\n.\nfoo\n\n  \n \njsonData\n.\nfoo\n.\nbar\n\n  \n \njsonData\n.\nfoo\n.\nbar\n.\nbaz\n\n  \n \njsonData\n.\nfoo\n.\nbar\n.\nbaz\n.\nquux\n\n  \n \njsonData\n.\nfoo\n.\nbar\n.\nbaz\n.\nquux\n.\nxyzzy\n;\n\n\n\n// good\n\n\n$\n.\najax\n({\n\n  \nmethod\n:\n \nPOST\n,\n\n  \nurl\n:\n \nhttps://airbnb.com/\n,\n\n  \ndata\n:\n \n{\n \nname\n:\n \nJohn\n \n},\n\n\n})\n\n  \n.\ndone\n(()\n \n=\n \nconsole\n.\nlog\n(\nCongratulations!\n))\n\n  \n.\nfail\n(()\n \n=\n \nconsole\n.\nlog\n(\nYou have failed this city.\n));\n\n\n\n\n\n\n\u2b06 back to top\n\n\nCommas\n\n\n\n\n\n\n19.1\n Leading commas: \nNope\n. eslint: \ncomma-style\n jscs: \nrequireCommaBeforeLineBreak\n\n\n\n\n// bad\n\n\nconst\n \nstory\n \n=\n \n[\n\n    \nonce\n\n  \n,\n \nupon\n\n  \n,\n \naTime\n\n\n];\n\n\n\n// good\n\n\nconst\n \nstory\n \n=\n \n[\n\n  \nonce\n,\n\n  \nupon\n,\n\n  \naTime\n,\n\n\n];\n\n\n\n// bad\n\n\nconst\n \nhero\n \n=\n \n{\n\n    \nfirstName\n:\n \nAda\n\n  \n,\n \nlastName\n:\n \nLovelace\n\n  \n,\n \nbirthYear\n:\n \n1815\n\n  \n,\n \nsuperPower\n:\n \ncomputers\n\n\n};\n\n\n\n// good\n\n\nconst\n \nhero\n \n=\n \n{\n\n  \nfirstName\n:\n \nAda\n,\n\n  \nlastName\n:\n \nLovelace\n,\n\n  \nbirthYear\n:\n \n1815\n,\n\n  \nsuperPower\n:\n \ncomputers\n,\n\n\n};\n\n\n\n\n\n\n\n\n19.2\n Additional trailing comma: \nYup.\n eslint: \ncomma-dangle\n jscs: \nrequireTrailingComma\n\n\n\n\n\n\nWhy? This leads to cleaner git diffs. Also, transpilers like Babel will remove the additional trailing comma in the transpiled code which means you don't have to worry about the \ntrailing comma problem\n in legacy browsers.\n\n\n\n\n// bad - git diff without trailing comma\nconst hero = {\n     firstName: \nFlorence\n,\n\n-    lastName: \nNightingale\n\n\n+    lastName: \nNightingale\n,\n\n\n+    inventorOf: [\ncoxcomb chart\n, \nmodern nursing\n]\n\n};\n\n// good - git diff with trailing comma\nconst hero = {\n     firstName: \nFlorence\n,\n     lastName: \nNightingale\n,\n\n+    inventorOf: [\ncoxcomb chart\n, \nmodern nursing\n],\n\n};\n\n\n\n\n\n// bad\n\n\nconst\n \nhero\n \n=\n \n{\n\n  \nfirstName\n:\n \nDana\n,\n\n  \nlastName\n:\n \nScully\n\n\n};\n\n\n\nconst\n \nheroes\n \n=\n \n[\n\n  \nBatman\n,\n\n  \nSuperman\n\n\n];\n\n\n\n// good\n\n\nconst\n \nhero\n \n=\n \n{\n\n  \nfirstName\n:\n \nDana\n,\n\n  \nlastName\n:\n \nScully\n,\n\n\n};\n\n\n\nconst\n \nheroes\n \n=\n \n[\n\n  \nBatman\n,\n\n  \nSuperman\n,\n\n\n];\n\n\n\n// bad\n\n\nfunction\n \ncreateHero\n(\n\n  \nfirstName\n,\n\n  \nlastName\n,\n\n  \ninventorOf\n\n\n)\n \n{\n\n  \n// does nothing\n\n\n}\n\n\n\n// good\n\n\nfunction\n \ncreateHero\n(\n\n  \nfirstName\n,\n\n  \nlastName\n,\n\n  \ninventorOf\n,\n\n\n)\n \n{\n\n  \n// does nothing\n\n\n}\n\n\n\n// good (note that a comma must not appear after a \nrest\n element)\n\n\nfunction\n \ncreateHero\n(\n\n  \nfirstName\n,\n\n  \nlastName\n,\n\n  \ninventorOf\n,\n\n  \n...\nheroArgs\n\n\n)\n \n{\n\n  \n// does nothing\n\n\n}\n\n\n\n// bad\n\n\ncreateHero\n(\n\n  \nfirstName\n,\n\n  \nlastName\n,\n\n  \ninventorOf\n\n\n);\n\n\n\n// good\n\n\ncreateHero\n(\n\n  \nfirstName\n,\n\n  \nlastName\n,\n\n  \ninventorOf\n,\n\n\n);\n\n\n\n// good (note that a comma must not appear after a \nrest\n element)\n\n\ncreateHero\n(\n\n  \nfirstName\n,\n\n  \nlastName\n,\n\n  \ninventorOf\n,\n\n  \n...\nheroArgs\n\n\n);\n\n\n\n\n\n\n\u2b06 back to top\n\n\nSemicolons\n\n\n\n\n\n\n20.1\n \nYup.\n eslint: \nsemi\n jscs: \nrequireSemicolons\n\n\n\n\n// bad\n\n\n(\nfunction\n \n()\n \n{\n\n  \nconst\n \nname\n \n=\n \nSkywalker\n\n  \nreturn\n \nname\n\n\n})()\n\n\n\n// good\n\n\n(\nfunction\n \n()\n \n{\n\n  \nconst\n \nname\n \n=\n \nSkywalker\n;\n\n  \nreturn\n \nname\n;\n\n\n}());\n\n\n\n// good, but legacy (guards against the function becoming an argument when two files with IIFEs are concatenated)\n\n\n;((()\n \n=\n \n{\n\n  \nconst\n \nname\n \n=\n \nSkywalker\n;\n\n  \nreturn\n \nname\n;\n\n\n})());\n\n\n\n\n\n\nRead more\n.\n\n\n\u2b06 back to top\n\n\nType Casting \n Coercion\n\n\n\n\n\n\n\n\n21.1\n Perform type coercion at the beginning of the statement.\n\n\n\n\n\n\n21.2\n  Strings:\n\n\n\n\n\n\n// =\n this.reviewScore = 9;\n\n\n\n// bad\n\n\nconst\n \ntotalScore\n \n=\n \nthis\n.\nreviewScore\n \n+\n \n;\n \n// invokes this.reviewScore.valueOf()\n\n\n\n// bad\n\n\nconst\n \ntotalScore\n \n=\n \nthis\n.\nreviewScore\n.\ntoString\n();\n \n// isn\nt guaranteed to return a string\n\n\n\n// good\n\n\nconst\n \ntotalScore\n \n=\n \nString\n(\nthis\n.\nreviewScore\n);\n\n\n\n\n\n\n\n\n21.3\n Numbers: Use \nNumber\n for type casting and \nparseInt\n always with a radix for parsing strings. eslint: \nradix\n\n\n\n\nconst\n \ninputValue\n \n=\n \n4\n;\n\n\n\n// bad\n\n\nconst\n \nval\n \n=\n \nnew\n \nNumber\n(\ninputValue\n);\n\n\n\n// bad\n\n\nconst\n \nval\n \n=\n \n+\ninputValue\n;\n\n\n\n// bad\n\n\nconst\n \nval\n \n=\n \ninputValue\n \n \n0\n;\n\n\n\n// bad\n\n\nconst\n \nval\n \n=\n \nparseInt\n(\ninputValue\n);\n\n\n\n// good\n\n\nconst\n \nval\n \n=\n \nNumber\n(\ninputValue\n);\n\n\n\n// good\n\n\nconst\n \nval\n \n=\n \nparseInt\n(\ninputValue\n,\n \n10\n);\n\n\n\n\n\n\n\n\n21.4\n If for whatever reason you are doing something wild and \nparseInt\n is your bottleneck and need to use Bitshift for \nperformance reasons\n, leave a comment explaining why and what you're doing.\n\n\n\n\n// good\n\n\n/**\n\n\n * parseInt was the reason my code was slow.\n\n\n * Bitshifting the String to coerce it to a\n\n\n * Number made it a lot faster.\n\n\n */\n\n\nconst\n \nval\n \n=\n \ninputValue\n \n \n0\n;\n\n\n\n\n\n\n\n\n21.5\n Be careful when using bitshift operations.\n\n\nNumbers are represented as \n64-bit values\n, but  bitshift operations always return a 32-bit integer (\nsource\n). Bitshift can lead to unexpected behavior for integer values larger than 32 bits. \nDiscussion\n. Largest signed 32-bit Int is 2,147,483,647:\n\n\n\n\n2147483647\n \n \n0\n;\n \n// =\n 2147483647\n\n\n2147483648\n \n \n0\n;\n \n// =\n -2147483648\n\n\n2147483649\n \n \n0\n;\n \n// =\n -2147483647\n\n\n\n\n\n\n\n\n21.6\n Booleans:\n\n\n\n\nconst\n \nage\n \n=\n \n0\n;\n\n\n\n// bad\n\n\nconst\n \nhasAge\n \n=\n \nnew\n \nBoolean\n(\nage\n);\n\n\n\n// good\n\n\nconst\n \nhasAge\n \n=\n \nBoolean\n(\nage\n);\n\n\n\n// best\n\n\nconst\n \nhasAge\n \n=\n \n!!\nage\n;\n\n\n\n\n\n\n\u2b06 back to top\n\n\nNaming Conventions\n\n\n\n\n\n\n22.1\n Avoid single letter names. Be descriptive with your naming. eslint: \nid-length\n\n\n\n\n// bad\n\n\nfunction\n \nq\n()\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n// good\n\n\nfunction\n \nquery\n()\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n\n\n\n\n\n22.2\n Use camelCase when naming objects, functions, and instances. eslint: \ncamelcase\n jscs: \nrequireCamelCaseOrUpperCaseIdentifiers\n\n\n\n\n// bad\n\n\nconst\n \nOBJEcttsssss\n \n=\n \n{};\n\n\nconst\n \nthis_is_my_object\n \n=\n \n{};\n\n\nfunction\n \nc\n()\n \n{}\n\n\n\n// good\n\n\nconst\n \nthisIsMyObject\n \n=\n \n{};\n\n\nfunction\n \nthisIsMyFunction\n()\n \n{}\n\n\n\n\n\n\n\n\n22.3\n Use PascalCase only when naming constructors or classes. eslint: \nnew-cap\n jscs: \nrequireCapitalizedConstructors\n\n\n\n\n// bad\n\n\nfunction\n \nuser\n(\noptions\n)\n \n{\n\n  \nthis\n.\nname\n \n=\n \noptions\n.\nname\n;\n\n\n}\n\n\n\nconst\n \nbad\n \n=\n \nnew\n \nuser\n({\n\n  \nname\n:\n \nnope\n,\n\n\n});\n\n\n\n// good\n\n\nclass\n \nUser\n \n{\n\n  \nconstructor\n(\noptions\n)\n \n{\n\n    \nthis\n.\nname\n \n=\n \noptions\n.\nname\n;\n\n  \n}\n\n\n}\n\n\n\nconst\n \ngood\n \n=\n \nnew\n \nUser\n({\n\n  \nname\n:\n \nyup\n,\n\n\n});\n\n\n\n\n\n\n\n- \n22.4\n Do not use trailing or leading underscores. eslint: \nno-underscore-dangle\n jscs: \ndisallowDanglingUnderscores\n\n\n\n\nWhy? JavaScript does not have the concept of privacy in terms of properties or methods. Although a leading underscore is a common convention to mean \u201cprivate\u201d, in fact, these properties are fully public, and as such, are part of your public API contract. This convention might lead developers to wrongly think that a change won't count as breaking, or that tests aren't needed. tl;dr: if you want something to be \u201cprivate\u201d, it must not be observably present.\n\n\n\n\n// bad\n\n\nthis\n.\n__firstName__\n \n=\n \nPanda\n;\n\n\nthis\n.\nfirstName_\n \n=\n \nPanda\n;\n\n\nthis\n.\n_firstName\n \n=\n \nPanda\n;\n\n\n\n// good\n\n\nthis\n.\nfirstName\n \n=\n \nPanda\n;\n\n\n\n\n\n\n\n- \n22.5\n Don't save references to \nthis\n. Use arrow functions or \nFunction#bind\n. jscs: \ndisallowNodeTypes\n\n\n// bad\n\n\nfunction\n \nfoo\n()\n \n{\n\n  \nconst\n \nself\n \n=\n \nthis\n;\n\n  \nreturn\n \nfunction\n \n()\n \n{\n\n    \nconsole\n.\nlog\n(\nself\n);\n\n  \n};\n\n\n}\n\n\n\n// bad\n\n\nfunction\n \nfoo\n()\n \n{\n\n  \nconst\n \nthat\n \n=\n \nthis\n;\n\n  \nreturn\n \nfunction\n \n()\n \n{\n\n    \nconsole\n.\nlog\n(\nthat\n);\n\n  \n};\n\n\n}\n\n\n\n// good\n\n\nfunction\n \nfoo\n()\n \n{\n\n  \nreturn\n \n()\n \n=\n \n{\n\n    \nconsole\n.\nlog\n(\nthis\n);\n\n  \n};\n\n\n}\n\n\n\n\n\n\n\n- \n22.6\n A base filename should exactly match the name of its default export.\n\n\n// file 1 contents\n\n\nclass\n \nCheckBox\n \n{\n\n  \n// ...\n\n\n}\n\n\nexport\n \ndefault\n \nCheckBox\n;\n\n\n\n// file 2 contents\n\n\nexport\n \ndefault\n \nfunction\n \nfortyTwo\n()\n \n{\n \nreturn\n \n42\n;\n \n}\n\n\n\n// file 3 contents\n\n\nexport\n \ndefault\n \nfunction\n \ninsideDirectory\n()\n \n{}\n\n\n\n// in some other file\n\n\n// bad\n\n\nimport\n \nCheckBox\n \nfrom\n \n./checkBox\n;\n \n// PascalCase import/export, camelCase filename\n\n\nimport\n \nFortyTwo\n \nfrom\n \n./FortyTwo\n;\n \n// PascalCase import/filename, camelCase export\n\n\nimport\n \nInsideDirectory\n \nfrom\n \n./InsideDirectory\n;\n \n// PascalCase import/filename, camelCase export\n\n\n\n// bad\n\n\nimport\n \nCheckBox\n \nfrom\n \n./check_box\n;\n \n// PascalCase import/export, snake_case filename\n\n\nimport\n \nforty_two\n \nfrom\n \n./forty_two\n;\n \n// snake_case import/filename, camelCase export\n\n\nimport\n \ninside_directory\n \nfrom\n \n./inside_directory\n;\n \n// snake_case import, camelCase export\n\n\nimport\n \nindex\n \nfrom\n \n./inside_directory/index\n;\n \n// requiring the index file explicitly\n\n\nimport\n \ninsideDirectory\n \nfrom\n \n./insideDirectory/index\n;\n \n// requiring the index file explicitly\n\n\n\n// good\n\n\nimport\n \nCheckBox\n \nfrom\n \n./CheckBox\n;\n \n// PascalCase export/import/filename\n\n\nimport\n \nfortyTwo\n \nfrom\n \n./fortyTwo\n;\n \n// camelCase export/import/filename\n\n\nimport\n \ninsideDirectory\n \nfrom\n \n./insideDirectory\n;\n \n// camelCase export/import/directory name/implicit \nindex\n\n\n// ^ supports both insideDirectory.js and insideDirectory/index.js\n\n\n\n\n\n\n\n- \n22.7\n Use camelCase when you export-default a function. Your filename should be identical to your function's name.\n\n\nfunction\n \nmakeStyleGuide\n()\n \n{\n\n  \n// ...\n\n\n}\n\n\n\nexport\n \ndefault\n \nmakeStyleGuide\n;\n\n\n\n\n\n\n\n- \n22.8\n Use PascalCase when you export a constructor / class / singleton / function library / bare object.\n\n\nconst\n \nAirbnbStyleGuide\n \n=\n \n{\n\n  \nes6\n:\n \n{\n\n  \n},\n\n\n};\n\n\n\nexport\n \ndefault\n \nAirbnbStyleGuide\n;\n\n\n\n\n\n\n\n- \n22.9\n Acronyms and initialisms should always be all capitalized, or all lowercased.\n\n\n\n\nWhy? Names are for readability, not to appease a computer algorithm.\n\n\n\n\n// bad\n\n\nimport\n \nSmsContainer\n \nfrom\n \n./containers/SmsContainer\n;\n\n\n\n// bad\n\n\nconst\n \nHttpRequests\n \n=\n \n[\n\n  \n// ...\n\n\n];\n\n\n\n// good\n\n\nimport\n \nSMSContainer\n \nfrom\n \n./containers/SMSContainer\n;\n\n\n\n// good\n\n\nconst\n \nHTTPRequests\n \n=\n \n[\n\n  \n// ...\n\n\n];\n\n\n\n// best\n\n\nimport\n \nTextMessageContainer\n \nfrom\n \n./containers/TextMessageContainer\n;\n\n\n\n// best\n\n\nconst\n \nRequests\n \n=\n \n[\n\n  \n// ...\n\n\n];\n\n\n\n\n\n\n\u2b06 back to top\n\n\nAccessors\n\n\n\n\n\n- \n23.1\n Accessor functions for properties are not required.\n\n\n\n- \n23.2\n Do not use JavaScript getters/setters as they cause unexpected side effects and are harder to test, maintain, and reason about. Instead, if you do make accessor functions, use getVal() and setVal('hello').\n\n\n// bad\n\n\nclass\n \nDragon\n \n{\n\n  \nget\n \nage\n()\n \n{\n\n    \n// ...\n\n  \n}\n\n\n  \nset\n \nage\n(\nvalue\n)\n \n{\n\n    \n// ...\n\n  \n}\n\n\n}\n\n\n\n// good\n\n\nclass\n \nDragon\n \n{\n\n  \ngetAge\n()\n \n{\n\n    \n// ...\n\n  \n}\n\n\n  \nsetAge\n(\nvalue\n)\n \n{\n\n    \n// ...\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n- \n23.3\n If the property/method is a \nboolean\n, use \nisVal()\n or \nhasVal()\n.\n\n\n// bad\n\n\nif\n \n(\n!\ndragon\n.\nage\n())\n \n{\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n// good\n\n\nif\n \n(\n!\ndragon\n.\nhasAge\n())\n \n{\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n\n\n\n\n- \n23.4\n It's okay to create get() and set() functions, but be consistent.\n\n\nclass\n \nJedi\n \n{\n\n  \nconstructor\n(\noptions\n \n=\n \n{})\n \n{\n\n    \nconst\n \nlightsaber\n \n=\n \noptions\n.\nlightsaber\n \n||\n \nblue\n;\n\n    \nthis\n.\nset\n(\nlightsaber\n,\n \nlightsaber\n);\n\n  \n}\n\n\n  \nset\n(\nkey\n,\n \nval\n)\n \n{\n\n    \nthis\n[\nkey\n]\n \n=\n \nval\n;\n\n  \n}\n\n\n  \nget\n(\nkey\n)\n \n{\n\n    \nreturn\n \nthis\n[\nkey\n];\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\u2b06 back to top\n\n\nEvents\n\n\n\n\n\n- \n24.1\n When attaching data payloads to events (whether DOM events or something more proprietary like Backbone events), pass a hash instead of a raw value. This allows a subsequent contributor to add more data to the event payload without finding and updating every handler for the event. For example, instead of:\n\n\n// bad\n\n\n$\n(\nthis\n).\ntrigger\n(\nlistingUpdated\n,\n \nlisting\n.\nid\n);\n\n\n\n// ...\n\n\n\n$\n(\nthis\n).\non\n(\nlistingUpdated\n,\n \n(\ne\n,\n \nlistingId\n)\n \n=\n \n{\n\n  \n// do something with listingId\n\n\n});\n\n\n\n\n\n\nprefer:\n\n\n// good\n\n\n$\n(\nthis\n).\ntrigger\n(\nlistingUpdated\n,\n \n{\n \nlistingId\n:\n \nlisting\n.\nid\n \n});\n\n\n\n// ...\n\n\n\n$\n(\nthis\n).\non\n(\nlistingUpdated\n,\n \n(\ne\n,\n \ndata\n)\n \n=\n \n{\n\n  \n// do something with data.listingId\n\n\n});\n\n\n\n\n\n\n\u2b06 back to top\n\n\n\n\nECMAScript 6+ (ES 2015+) Styles\n\n\n\n\n\n\n\n\n27.1\n This is a collection of links to the various ES6 features.\n\n\n\n\n\n\nArrow Functions\n\n\n\n\nClasses\n\n\nObject Shorthand\n\n\nObject Concise\n\n\nObject Computed Properties\n\n\nTemplate Strings\n\n\nDestructuring\n\n\nDefault Parameters\n\n\nRest\n\n\nArray Spreads\n\n\nLet and Const\n\n\nIterators and Generators\n\n\nModules\n\n\n\n\n\n\nDo not use \nTC39 proposals\n that have not reached stage 3.\n\n\nThey are not finalized\n, and they are subject to change or to be withdrawn entirely. We want to use JavaScript, and proposals are not JavaScript yet.\n\n\n\n\n\u2b06 back to top\n\n\nTesting\n\n\n\n\n\n\n28.1\n \nYup.\n\n\n\n\nfunction\n \nfoo\n()\n \n{\n\n  \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\n\n\n28.2\n \nNo, but seriously\n:\n\n\nWhichever testing framework you use, you should be writing tests!\n\n\nStrive to write many small pure functions, and minimize where mutations occur.\n\n\nBe cautious about stubs and mocks - they can make your tests more brittle.\n\n\nWe primarily use \nmocha\n at Airbnb. \ntape\n is also used occasionally for small, separate modules.\n\n\n100% test coverage is a good goal to strive for, even if it's not always practical to reach it.\n\n\nWhenever you fix a bug, \nwrite a regression test\n. A bug fixed without a regression test is almost certainly going to break again in the future.\n\n\n\n\n\n\n\n\n\u2b06 back to top\n\n\nPerformance\n\n\n\n\n\n\nOn Layout \n Web Performance\n\n\nString vs Array Concat\n\n\nTry/Catch Cost In a Loop\n\n\nBang Function\n\n\njQuery Find vs Context, Selector\n\n\ninnerHTML vs textContent for script text\n\n\nLong String Concatenation\n\n\nAre Javascript functions like \nmap()\n, \nreduce()\n, and \nfilter()\n optimized for traversing arrays?\n\n\nLoading...\n\n\n\n\n\u2b06 back to top\n\n\nResources\n\n\n\n\nLearning ES6\n\n\n\n\nDraft ECMA 2015 (ES6) Spec\n\n\nExploringJS\n\n\nES6 Compatibility Table\n\n\nComprehensive Overview of ES6 Features\n\n\n\n\nRead This\n\n\n\n\nStandard ECMA-262\n\n\n\n\nTools\n\n\n\n\nCode Style Linters\n\n\nESlint\n - \nAirbnb Style .eslintrc\n\n\nJSHint\n - \nAirbnb Style .jshintrc\n\n\nJSCS\n - \nAirbnb Style Preset\n\n\n\n\nOther Style Guides\n\n\n\n\nGoogle JavaScript Style Guide\n\n\njQuery Core Style Guidelines\n\n\nPrinciples of Writing Consistent, Idiomatic JavaScript\n\n\n\n\nOther Styles\n\n\n\n\nNaming this in nested functions\n - Christian Johansen\n\n\nConditional Callbacks\n - Ross Allen\n\n\nPopular JavaScript Coding Conventions on GitHub\n - JeongHoon Byun\n\n\nMultiple var statements in JavaScript, not superfluous\n - Ben Alman\n\n\n\n\nFurther Reading\n\n\n\n\nUnderstanding JavaScript Closures\n - Angus Croll\n\n\nBasic JavaScript for the impatient programmer\n - Dr. Axel Rauschmayer\n\n\nYou Might Not Need jQuery\n - Zack Bloom \n Adam Schwartz\n\n\nES6 Features\n - Luke Hoban\n\n\nFrontend Guidelines\n - Benjamin De Cock\n\n\n\n\nBooks\n\n\n\n\nJavaScript: The Good Parts\n - Douglas Crockford\n\n\nJavaScript Patterns\n - Stoyan Stefanov\n\n\nPro JavaScript Design Patterns\n  - Ross Harmes and Dustin Diaz\n\n\nHigh Performance Web Sites: Essential Knowledge for Front-End Engineers\n - Steve Souders\n\n\nMaintainable JavaScript\n - Nicholas C. Zakas\n\n\nJavaScript Web Applications\n - Alex MacCaw\n\n\nPro JavaScript Techniques\n - John Resig\n\n\nSmashing Node.js: JavaScript Everywhere\n - Guillermo Rauch\n\n\nSecrets of the JavaScript Ninja\n - John Resig and Bear Bibeault\n\n\nHuman JavaScript\n - Henrik Joreteg\n\n\nSuperhero.js\n - Kim Joar Bekkelund, Mads Mob\u00e6k, \n Olav Bjorkoy\n\n\nJSBooks\n - Julien Bouquillon\n\n\nThird Party JavaScript\n - Ben Vinegar and Anton Kovalyov\n\n\nEffective JavaScript: 68 Specific Ways to Harness the Power of JavaScript\n - David Herman\n\n\nEloquent JavaScript\n - Marijn Haverbeke\n\n\nYou Don't Know JS: ES6 \n Beyond\n - Kyle Simpson\n\n\n\n\nBlogs\n\n\n\n\nJavaScript Weekly\n\n\nJavaScript, JavaScript...\n\n\nBocoup Weblog\n\n\nAdequately Good\n\n\nNCZOnline\n\n\nPerfection Kills\n\n\nBen Alman\n\n\nDmitry Baranovskiy\n\n\nDustin Diaz\n\n\nnettuts\n\n\n\n\nPodcasts\n\n\n\n\nJavaScript Air\n\n\nJavaScript Jabber\n\n\n\n\n\u2b06 back to top",
            "title": "JS Styleguide"
        },
        {
            "location": "/js/javascript/#venngage-javascript-style-guide",
            "text": "Based off of  AirBnB's style guide.   Types  References  Objects  Arrays  Destructuring  Strings  Functions  Arrow Functions  Classes   Constructors  Modules  Iterators and Generators  Properties  Variables  Hoisting  Comparison Operators   Equality  Blocks  Comments  Whitespace  Commas  Semicolons  Type Casting   Coercion  Naming Conventions  Accessors  Events  ECMAScript 6+ (ES 2015+) Styles  Testing  Performance  Resources",
            "title": "Venngage JavaScript Style Guide"
        },
        {
            "location": "/js/javascript/#types",
            "text": "1.1   Primitives : When you access a primitive type you work directly on its value.    string   number  boolean  null  undefined   const   foo   =   1 ;  let   bar   =   foo ;  bar   =   9 ;  console . log ( foo ,   bar );   // =  1, 9     1.2    Complex : When you access a complex type you work on a reference to its value.    object   array  function   const   foo   =   [ 1 ,   2 ];  const   bar   =   foo ;  bar [ 0 ]   =   9 ;  console . log ( foo [ 0 ],   bar [ 0 ]);   // =  9, 9   \u2b06 back to top",
            "title": "Types"
        },
        {
            "location": "/js/javascript/#references",
            "text": "2.1  Use  const  for all of your references; avoid using  var . eslint:  prefer-const ,  no-const-assign    Tip  This ensures that you can't reassign your references, which can lead to bugs and difficult to comprehend code.   // bad  var   a   =   1 ;  var   b   =   2 ;  // good  const   a   =   1 ;  const   b   =   2 ;    2.2  If you must reassign references, use  let  instead of  var . eslint:  no-var  jscs:  disallowVar    Why?  let  is block-scoped rather than function-scoped like  var .   // bad  var   count   =   1 ;  if   ( true )   {  count   +=   1 ;  }  // good, use the let.  let   count   =   1 ;  if   ( true )   {  count   +=   1 ;  }    2.3  Note that both  let  and  const  are block-scoped.   // const and let only exist in the blocks they are defined in.  {  let   a   =   1 ;  const   b   =   1 ;  }  console . log ( a );   // ReferenceError  console . log ( b );   // ReferenceError   \u2b06 back to top",
            "title": "References"
        },
        {
            "location": "/js/javascript/#objects",
            "text": "3.1  Use the literal syntax for object creation. eslint:  no-new-object   // bad  const   item   =   new   Object ();  // good  const   item   =   {};    3.2  Use computed property names when creating objects with dynamic property names.    Why? They allow you to define all the properties of an object in one place.   function   getKey ( k )   {  return   `a key named  ${ k } ` ;  }  // bad  const   obj   =   {  id :   5 ,  name :   San Francisco ,  };  obj [ getKey ( enabled )]   =   true ;  // good  const   obj   =   {  id :   5 ,  name :   San Francisco ,  [ getKey ( enabled )] :   true ,  };    3.3  Use object method shorthand. eslint:  object-shorthand  jscs:  requireEnhancedObjectLiterals   // bad  const   atom   =   {  value :   1 ,  addValue :   function   ( value )   { \n   return   atom . value   +   value ;  },  };  // good  const   atom   =   {  value :   1 ,  addValue ( value )   { \n   return   atom . value   +   value ;  },  };    3.4  Use property value shorthand. eslint:  object-shorthand  jscs:  requireEnhancedObjectLiterals    Why? It is shorter to write and descriptive.   const   lukeSkywalker   =   Luke Skywalker ;  // bad  const   obj   =   {  lukeSkywalker :   lukeSkywalker ,  };  // good  const   obj   =   {  lukeSkywalker ,  };    3.5  Group your shorthand properties at the beginning of your object declaration.    Why? It's easier to tell which properties are using the shorthand.   const   anakinSkywalker   =   Anakin Skywalker ;  const   lukeSkywalker   =   Luke Skywalker ;  // bad  const   obj   =   {  episodeOne :   1 ,  twoJediWalkIntoACantina :   2 ,  lukeSkywalker ,  episodeThree :   3 ,  mayTheFourth :   4 ,  anakinSkywalker ,  };  // good  const   obj   =   {  lukeSkywalker ,  anakinSkywalker ,  episodeOne :   1 ,  twoJediWalkIntoACantina :   2 ,  episodeThree :   3 ,  mayTheFourth :   4 ,  };    3.6  Only quote properties that are invalid identifiers. eslint:  quote-props  jscs:  disallowQuotedKeysInObjects    Why? In general we consider it subjectively easier to read. It improves syntax highlighting, and is also more easily optimized by many JS engines.   // bad  const   bad   =   {  foo :   3 ,  bar :   4 ,  data-blah :   5 ,  };  // good  const   good   =   {  foo :   3 ,  bar :   4 ,  data-blah :   5 ,  };    3.7  Do not call  Object.prototype  methods directly, such as  hasOwnProperty ,  propertyIsEnumerable , and  isPrototypeOf .    Why? These methods may be shadowed by properties on the object in question - consider  { hasOwnProperty: false }  - or, the object may be a null object ( Object.create(null) ).   // bad  console . log ( object . hasOwnProperty ( key ));  // good  console . log ( Object . prototype . hasOwnProperty . call ( object ,   key ));  // best  const   has   =   Object . prototype . hasOwnProperty ;   // cache the lookup once, in module scope.  /* or */  import   has   from   has ;  // ...  console . log ( has . call ( object ,   key ));    3.8  Prefer the object spread operator over  Object.assign  to shallow-copy objects. Use the object rest operator to get a new object with certain properties omitted.   // very bad  const   original   =   {   a :   1 ,   b :   2   };  const   copy   =   Object . assign ( original ,   {   c :   3   });   // this mutates `original` \u0ca0_\u0ca0  delete   copy . a ;   // so does this  // bad  const   original   =   {   a :   1 ,   b :   2   };  const   copy   =   Object . assign ({},   original ,   {   c :   3   });   // copy =  { a: 1, b: 2, c: 3 }  // good  const   original   =   {   a :   1 ,   b :   2   };  const   copy   =   {   ... original ,   c :   3   };   // copy =  { a: 1, b: 2, c: 3 }  const   {   a ,   ... noA   }   =   copy ;   // noA =  { b: 2, c: 3 }   \u2b06 back to top",
            "title": "Objects"
        },
        {
            "location": "/js/javascript/#arrays",
            "text": "4.1  Use the literal syntax for array creation. eslint:  no-array-constructor   // bad  const   items   =   new   Array ();  // good  const   items   =   [];    4.2  Use  Array#push  instead of direct assignment to add items to an array.   const   someStack   =   [];  // bad  someStack [ someStack . length ]   =   abracadabra ;  // good  someStack . push ( abracadabra );    4.3  Use array spreads  ...  to copy arrays.   // bad  const   len   =   items . length ;  const   itemsCopy   =   [];  let   i ;  for   ( i   =   0 ;   i     len ;   i   +=   1 )   {  itemsCopy [ i ]   =   items [ i ];  }  // good  const   itemsCopy   =   [... items ];    4.4  To convert an array-like object to an array, use  Array.from .   const   foo   =   document . querySelectorAll ( .foo );  const   nodes   =   Array . from ( foo );    4.5  Use return statements in array method callbacks. It's ok to omit the return if the function body consists of a single statement following  8.2 . eslint:  array-callback-return   // good  [ 1 ,   2 ,   3 ]. map (( x )   =   { \n   const   y   =   x   +   1 ; \n   return   x   *   y ;  });  // good  [ 1 ,   2 ,   3 ]. map ( x   =   x   +   1 );  // bad  const   flat   =   {};  [[ 0 ,   1 ],   [ 2 ,   3 ],   [ 4 ,   5 ]]. reduce (( memo ,   item ,   index )   =   { \n   const   flatten   =   memo . concat ( item ); \n   flat [ index ]   =   flatten ;  });  // good  const   flat   =   {};  [[ 0 ,   1 ],   [ 2 ,   3 ],   [ 4 ,   5 ]]. reduce (( memo ,   item ,   index )   =   { \n   const   flatten   =   memo . concat ( item ); \n   flat [ index ]   =   flatten ; \n   return   flatten ;  });  // bad  inbox . filter (( msg )   =   { \n   const   {   subject ,   author   }   =   msg ; \n   if   ( subject   ===   Mockingbird )   { \n     return   author   ===   Harper Lee ; \n   }   else   { \n     return   false ; \n   }  });  // good  inbox . filter (( msg )   =   { \n   const   {   subject ,   author   }   =   msg ; \n   if   ( subject   ===   Mockingbird )   { \n     return   author   ===   Harper Lee ; \n   } \n\n   return   false ;  });   \u2b06 back to top",
            "title": "Arrays"
        },
        {
            "location": "/js/javascript/#destructuring",
            "text": "5.1  Use object destructuring when accessing and using multiple properties of an object. jscs:  requireObjectDestructuring    Why? Destructuring saves you from creating temporary references for those properties.   // bad  function   getFullName ( user )   { \n   const   firstName   =   user . firstName ; \n   const   lastName   =   user . lastName ; \n\n   return   ` ${ firstName }   ${ lastName } ` ;  }  // good  function   getFullName ( user )   { \n   const   {   firstName ,   lastName   }   =   user ; \n   return   ` ${ firstName }   ${ lastName } ` ;  }  // best  function   getFullName ({   firstName ,   lastName   })   { \n   return   ` ${ firstName }   ${ lastName } ` ;  }    5.2  Use array destructuring. jscs:  requireArrayDestructuring   const   arr   =   [ 1 ,   2 ,   3 ,   4 ];  // bad  const   first   =   arr [ 0 ];  const   second   =   arr [ 1 ];  // good  const   [ first ,   second ]   =   arr ;    5.3  Use object destructuring for multiple return values, not array destructuring. jscs:  disallowArrayDestructuringReturn    Why? You can add new properties over time or change the order of things without breaking call sites.   // bad  function   processInput ( input )   { \n   // then a miracle occurs \n   return   [ left ,   right ,   top ,   bottom ];  }  // the caller needs to think about the order of return data  const   [ left ,   __ ,   top ]   =   processInput ( input );  // good  function   processInput ( input )   { \n   // then a miracle occurs \n   return   {   left ,   right ,   top ,   bottom   };  }  // the caller selects only the data they need  const   {   left ,   top   }   =   processInput ( input );   \u2b06 back to top",
            "title": "Destructuring"
        },
        {
            "location": "/js/javascript/#strings",
            "text": "6.1  Use single quotes  ''  for strings. eslint:  quotes  jscs:  validateQuoteMarks   // bad  const   name   =   Capt. Janeway ;  // bad - template literals should contain interpolation or newlines  const   name   =   `Capt. Janeway` ;  // good  const   name   =   Capt. Janeway ;    6.2  Strings that cause the line to go over 100 characters should not be written across multiple lines using string concatenation.    Why? Broken strings are painful to work with and make code less searchable.   // bad  const   errorMessage   =   This is a super long error that was thrown because \\  of Batman. When you stop to think about how Batman had anything to do \\  with this, you would get nowhere \\  fast. ;  // bad  const   errorMessage   =   This is a super long error that was thrown because    + \n   of Batman. When you stop to think about how Batman had anything to do    + \n   with this, you would get nowhere fast. ;  // good  const   errorMessage   =   This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast. ;    6.3  When programmatically building up strings, use template strings instead of concatenation. eslint:  prefer-template   template-curly-spacing  jscs:  requireTemplateStrings    Why? Template strings give you a readable, concise syntax with proper newlines and string interpolation features.   // bad  function   sayHi ( name )   { \n   return   How are you,    +   name   +   ? ;  }  // bad  function   sayHi ( name )   { \n   return   [ How are you,  ,   name ,   ? ]. join ();  }  // bad  function   sayHi ( name )   { \n   return   `How are you,  ${   name   } ?` ;  }  // good  function   sayHi ( name )   { \n   return   `How are you,  ${ name } ?` ;  }     6.4  Never use  eval()  on a string, it opens too many vulnerabilities.    6.5  Do not unnecessarily escape characters in strings. eslint:  no-useless-escape     Why? Backslashes harm readability, thus they should only be present when necessary.   // bad  const   foo   =   \\ this\\  \\i\\s \\ quoted\\ ;  // good  const   foo   =   \\ this\\  is  quoted ;  const   foo   =   `my name is  ${ name } ` ;   \u2b06 back to top",
            "title": "Strings"
        },
        {
            "location": "/js/javascript/#functions",
            "text": "7.1  Use named function expressions instead of function declarations. eslint:  func-style  jscs:  disallowFunctionDeclarations    Why? Function declarations are hoisted, which means that it\u2019s easy - too easy - to reference the function before it is defined in the file. This harms readability and maintainability. If you find that a function\u2019s definition is large or complex enough that it is interfering with understanding the rest of the file, then perhaps it\u2019s time to extract it to its own module! Don\u2019t forget to name the expression - anonymous functions can make it harder to locate the problem in an Error's call stack. ( Discussion )   // bad  function   foo ()   { \n   // ...  }  // bad  const   foo   =   function   ()   { \n   // ...  };  // good  const   foo   =   function   bar ()   { \n   // ...  };    7.2  Wrap immediately invoked function expressions in parentheses. eslint:  wrap-iife  jscs:  requireParenthesesAroundIIFE    Why? An immediately invoked function expression is a single unit - wrapping both it, and its invocation parens, in parens, cleanly expresses this. Note that in a world with modules everywhere, you almost never need an IIFE.   // immediately-invoked function expression (IIFE)  ( function   ()   { \n   console . log ( Welcome to the Internet. Please follow me. );  }());     7.3  Never declare a function in a non-function block (if, while, etc). Assign the function to a variable instead. Browsers will allow you to do it, but they all interpret it differently, which is bad news bears. eslint:  no-loop-func    7.4   Note:  ECMA-262 defines a  block  as a list of statements. A function declaration is not a statement.  Read ECMA-262's note on this issue .    // bad  if   ( currentUser )   { \n   function   test ()   { \n     console . log ( Nope. ); \n   }  }  // good  let   test ;  if   ( currentUser )   { \n   test   =   ()   =   { \n     console . log ( Yup. ); \n   };  }    7.5  Never name a parameter  arguments . This will take precedence over the  arguments  object that is given to every function scope.   // bad  function   foo ( name ,   options ,   arguments )   { \n   // ...  }  // good  function   foo ( name ,   options ,   args )   { \n   // ...  }    7.6  Never use  arguments , opt to use rest syntax  ...  instead. eslint:  prefer-rest-params    Why?  ...  is explicit about which arguments you want pulled. Plus, rest arguments are a real Array, and not merely Array-like like  arguments .   // bad  function   concatenateAll ()   { \n   const   args   =   Array . prototype . slice . call ( arguments ); \n   return   args . join ( );  }  // good  function   concatenateAll (... args )   { \n   return   args . join ( );  }    7.7  Use default parameter syntax rather than mutating function arguments.   // really bad  function   handleThings ( opts )   { \n   // No! We shouldn t mutate function arguments. \n   // Double bad: if opts is falsy it ll be set to an object which may \n   // be what you want but it can introduce subtle bugs. \n   opts   =   opts   ||   {}; \n   // ...  }  // still bad  function   handleThings ( opts )   { \n   if   ( opts   ===   void   0 )   { \n     opts   =   {}; \n   } \n   // ...  }  // good  function   handleThings ( opts   =   {})   { \n   // ...  }    7.8  Avoid side effects with default parameters.    Why? They are confusing to reason about.   var   b   =   1 ;  // bad  function   count ( a   =   b ++ )   { \n   console . log ( a );  }  count ();    // 1  count ();    // 2  count ( 3 );   // 3  count ();    // 3    7.9  Always put default parameters last.   // bad  function   handleThings ( opts   =   {},   name )   { \n   // ...  }  // good  function   handleThings ( name ,   opts   =   {})   { \n   // ...  }    7.10  Never use the Function constructor to create a new function. eslint:  no-new-func    Why? Creating a function in this way evaluates a string similarly to eval(), which opens vulnerabilities.   // bad  var   add   =   new   Function ( a ,   b ,   return a + b );  // still bad  var   subtract   =   Function ( a ,   b ,   return a - b );    7.11  Spacing in a function signature. eslint:  space-before-function-paren   space-before-blocks    Why? Consistency is good, and you shouldn\u2019t have to add or remove a space when adding or removing a name.   // bad  const   f   =   function (){};  const   g   =   function   (){};  const   h   =   function ()   {};  // good  const   x   =   function   ()   {};  const   y   =   function   a ()   {};    7.12  Never mutate parameters. eslint:  no-param-reassign    Why? Manipulating objects passed in as parameters can cause unwanted variable side effects in the original caller.   // bad  function   f1 ( obj )   { \n   obj . key   =   1 ;  }  // good  function   f2 ( obj )   { \n   const   key   =   Object . prototype . hasOwnProperty . call ( obj ,   key )   ?   obj . key   :   1 ;  }    7.13  Never reassign parameters. eslint:  no-param-reassign    Why? Reassigning parameters can lead to unexpected behavior, especially when accessing the  arguments  object. It can also cause optimization issues, especially in V8.   // bad  function   f1 ( a )   { \n   a   =   1 ; \n   // ...  }  function   f2 ( a )   { \n   if   ( ! a )   {   a   =   1 ;   } \n   // ...  }  // good  function   f3 ( a )   { \n   const   b   =   a   ||   1 ; \n   // ...  }  function   f4 ( a   =   1 )   { \n   // ...  }    7.14  Prefer the use of the spread operator  ...  to call variadic functions. eslint:  prefer-spread    Why? It's cleaner, you don't need to supply a context, and you can not easily compose  new  with  apply .   // bad  const   x   =   [ 1 ,   2 ,   3 ,   4 ,   5 ];  console . log . apply ( console ,   x );  // good  const   x   =   [ 1 ,   2 ,   3 ,   4 ,   5 ];  console . log (... x );  // bad  new   ( Function . prototype . bind . apply ( Date ,   [ null ,   2016 ,   8 ,   5 ]));  // good  new   Date (...[ 2016 ,   8 ,   5 ]);    7.15  Functions with multiline signatures, or invocations, should be indented just like every other multiline list in this guide: with each item on a line by itself, with a trailing comma on the last item.   // bad  function   foo ( bar , \n              baz , \n              quux )   { \n   // ...  }  // good  function   foo ( \n   bar , \n   baz , \n   quux ,  )   { \n   // ...  }  // bad  console . log ( foo , \n   bar , \n   baz );  // good  console . log ( \n   foo , \n   bar , \n   baz ,  );   \u2b06 back to top",
            "title": "Functions"
        },
        {
            "location": "/js/javascript/#arrow-functions",
            "text": "8.1  When you must use function expressions (as when passing an anonymous function), use arrow function notation. eslint:  prefer-arrow-callback ,  arrow-spacing  jscs:  requireArrowFunctions    Why? It creates a version of the function that executes in the context of  this , which is usually what you want, and is a more concise syntax.  Why not? If you have a fairly complicated function, you might move that logic out into its own function declaration.   // bad  [ 1 ,   2 ,   3 ]. map ( function   ( x )   { \n   const   y   =   x   +   1 ; \n   return   x   *   y ;  });  // good  [ 1 ,   2 ,   3 ]. map (( x )   =   { \n   const   y   =   x   +   1 ; \n   return   x   *   y ;  });    8.2  If the function body consists of a single expression, omit the braces and use the implicit return. Otherwise, keep the braces and use a  return  statement. eslint:  arrow-parens ,  arrow-body-style  jscs:   disallowParenthesesAroundArrowParam ,  requireShorthandArrowFunctions    Why? Syntactic sugar. It reads well when multiple functions are chained together.   // bad  [ 1 ,   2 ,   3 ]. map ( number   =   { \n   const   nextNumber   =   number   +   1 ; \n   `A string containing the  ${ nextNumber } .` ;  });  // good  [ 1 ,   2 ,   3 ]. map ( number   =   `A string containing the  ${ number } .` );  // good  [ 1 ,   2 ,   3 ]. map (( number )   =   { \n   const   nextNumber   =   number   +   1 ; \n   return   `A string containing the  ${ nextNumber } .` ;  });  // good  [ 1 ,   2 ,   3 ]. map (( number ,   index )   =   ({ \n   [ index ] :   number ,  }));    8.3  In case the expression spans over multiple lines, wrap it in parentheses for better readability.    Why? It shows clearly where the function starts and ends.   // bad  [ get ,   post ,   put ]. map ( httpMethod   =   Object . prototype . hasOwnProperty . call ( \n     httpMagicObjectWithAVeryLongName , \n     httpMethod , \n   )  );  // good  [ get ,   post ,   put ]. map ( httpMethod   =   ( \n   Object . prototype . hasOwnProperty . call ( \n     httpMagicObjectWithAVeryLongName , \n     httpMethod , \n   )  ));    8.4  If your function takes a single argument and doesn\u2019t use braces, omit the parentheses. Otherwise, always include parentheses around arguments. eslint:  arrow-parens  jscs:   disallowParenthesesAroundArrowParam    Why? Less visual clutter.   // bad  [ 1 ,   2 ,   3 ]. map (( x )   =   x   *   x );  // good  [ 1 ,   2 ,   3 ]. map ( x   =   x   *   x );  // good  [ 1 ,   2 ,   3 ]. map ( number   =   ( \n   `A long string with the  ${ number } . It\u2019s so long that we don\u2019t want it to take up space on the .map line!`  ));  // bad  [ 1 ,   2 ,   3 ]. map ( x   =   { \n   const   y   =   x   +   1 ; \n   return   x   *   y ;  });  // good  [ 1 ,   2 ,   3 ]. map (( x )   =   { \n   const   y   =   x   +   1 ; \n   return   x   *   y ;  });    8.5  Avoid confusing arrow function syntax ( = ) with comparison operators ( = ,  = ). eslint:  no-confusing-arrow   // bad  const   itemHeight   =   item   =   item . height     256   ?   item . largeSize   :   item . smallSize ;  // bad  const   itemHeight   =   ( item )   =   item . height     256   ?   item . largeSize   :   item . smallSize ;  // good  const   itemHeight   =   item   =   ( item . height     256   ?   item . largeSize   :   item . smallSize );  // good  const   itemHeight   =   ( item )   =   { \n   const   {   height ,   largeSize ,   smallSize   }   =   item ; \n   return   height     256   ?   largeSize   :   smallSize ;  };   \u2b06 back to top",
            "title": "Arrow Functions"
        },
        {
            "location": "/js/javascript/#classes-constructors",
            "text": "9.1  Always use  class . Avoid manipulating  prototype  directly.    Why?  class  syntax is more concise and easier to reason about.   // bad  function   Queue ( contents   =   [])   { \n   this . queue   =   [... contents ];  }  Queue . prototype . pop   =   function   ()   { \n   const   value   =   this . queue [ 0 ]; \n   this . queue . splice ( 0 ,   1 ); \n   return   value ;  };  // good  class   Queue   { \n   constructor ( contents   =   [])   { \n     this . queue   =   [... contents ]; \n   } \n   pop ()   { \n     const   value   =   this . queue [ 0 ]; \n     this . queue . splice ( 0 ,   1 ); \n     return   value ; \n   }  }    9.2  Use  extends  for inheritance.    Why? It is a built-in way to inherit prototype functionality without breaking  instanceof .   // bad  const   inherits   =   require ( inherits );  function   PeekableQueue ( contents )   { \n   Queue . apply ( this ,   contents );  }  inherits ( PeekableQueue ,   Queue );  PeekableQueue . prototype . peek   =   function   ()   { \n   return   this . queue [ 0 ];  };  // good  class   PeekableQueue   extends   Queue   { \n   peek ()   { \n     return   this . queue [ 0 ]; \n   }  }    9.3  Methods can return  this  to help with method chaining.   // bad  Jedi . prototype . jump   =   function   ()   { \n   this . jumping   =   true ; \n   return   true ;  };  Jedi . prototype . setHeight   =   function   ( height )   { \n   this . height   =   height ;  };  const   luke   =   new   Jedi ();  luke . jump ();   // =  true  luke . setHeight ( 20 );   // =  undefined  // good  class   Jedi   { \n   jump ()   { \n     this . jumping   =   true ; \n     return   this ; \n   } \n\n   setHeight ( height )   { \n     this . height   =   height ; \n     return   this ; \n   }  }  const   luke   =   new   Jedi ();  luke . jump () \n   . setHeight ( 20 );    9.4  It's okay to write a custom toString() method, just make sure it works successfully and causes no side effects.   class   Jedi   { \n   constructor ( options   =   {})   { \n     this . name   =   options . name   ||   no name ; \n   } \n\n   getName ()   { \n     return   this . name ; \n   } \n\n   toString ()   { \n     return   `Jedi -  ${ this . getName () } ` ; \n   }  }    9.5  Classes have a default constructor if one is not specified. An empty constructor function or one that just delegates to a parent class is unnecessary. eslint:  no-useless-constructor   // bad  class   Jedi   { \n   constructor ()   {} \n\n   getName ()   { \n     return   this . name ; \n   }  }  // bad  class   Rey   extends   Jedi   { \n   constructor (... args )   { \n     super (... args ); \n   }  }  // good  class   Rey   extends   Jedi   { \n   constructor (... args )   { \n     super (... args ); \n     this . name   =   Rey ; \n   }  }    9.6  Avoid duplicate class members. eslint:  no-dupe-class-members    Why? Duplicate class member declarations will silently prefer the last one - having duplicates is almost certainly a bug.   // bad  class   Foo   { \n   bar ()   {   return   1 ;   } \n   bar ()   {   return   2 ;   }  }  // good  class   Foo   { \n   bar ()   {   return   1 ;   }  }  // good  class   Foo   { \n   bar ()   {   return   2 ;   }  }   \u2b06 back to top",
            "title": "Classes &amp; Constructors"
        },
        {
            "location": "/js/javascript/#modules",
            "text": "10.1  Always use modules ( import / export ) over a non-standard module system. You can always transpile to your preferred module system.    Why? Modules are the future, let's start using the future now.   // bad  const   AirbnbStyleGuide   =   require ( ./AirbnbStyleGuide );  module . exports   =   AirbnbStyleGuide . es6 ;  // ok  import   AirbnbStyleGuide   from   ./AirbnbStyleGuide ;  export   default   AirbnbStyleGuide . es6 ;  // best  import   {   es6   }   from   ./AirbnbStyleGuide ;  export   default   es6 ;    10.2  Do not use wildcard imports.    Why? This makes sure you have a single default export.   // bad  import   *   as   AirbnbStyleGuide   from   ./AirbnbStyleGuide ;  // good  import   AirbnbStyleGuide   from   ./AirbnbStyleGuide ;    10.3  And do not export directly from an import.    Why? Although the one-liner is concise, having one clear way to import and one clear way to export makes things consistent.   // bad  // filename es6.js  export   {   es6   as   default   }   from   ./AirbnbStyleGuide ;  // good  // filename es6.js  import   {   es6   }   from   ./AirbnbStyleGuide ;  export   default   es6 ;    10.4  Only import from a path in one place.\neslint:  no-duplicate-imports  Why? Having multiple lines that import from the same path can make code harder to maintain.     // bad  import   foo   from   foo ;  // \u2026 some other imports \u2026 //  import   {   named1 ,   named2   }   from   foo ;  // good  import   foo ,   {   named1 ,   named2   }   from   foo ;  // good  import   foo ,   { \n   named1 , \n   named2 ,  }   from   foo ;    10.5  Do not export mutable bindings.\neslint:  import/no-mutable-exports  Why? Mutation should be avoided in general, but in particular when exporting mutable bindings. While this technique may be needed for some special cases, in general, only constant references should be exported.     // bad  let   foo   =   3 ;  export   {   foo   };  // good  const   foo   =   3 ;  export   {   foo   };    10.6  In modules with a single export, prefer default export over named export.\neslint:  import/prefer-default-export   // bad  export   function   foo ()   {}  // good  export   default   function   foo ()   {}    10.7  Put all  import s above non-import statements.\neslint:  import/first  Why? Since  import s are hoisted, keeping them all at the top prevents surprising behavior.     // bad  import   foo   from   foo ;  foo . init ();  import   bar   from   bar ;  // good  import   foo   from   foo ;  import   bar   from   bar ;  foo . init ();    10.8  Multiline imports should be indented just like multiline array and object literals.    Why? The curly braces follow the same indentation rules as every other curly brace block in the style guide, as do the trailing commas.   // bad  import   { longNameA ,   longNameB ,   longNameC ,   longNameD ,   longNameE }   from   path ;  // good  import   { \n   longNameA , \n   longNameB , \n   longNameC , \n   longNameD , \n   longNameE ,  }   from   path ;    10.9  Disallow Webpack loader syntax in module import statements.\neslint:  import/no-webpack-loader-syntax  Why? Since using Webpack syntax in the imports couples the code to a module bundler. Prefer using the loader syntax in  webpack.config.js .     // bad  import   fooSass   from   css!sass!foo.scss ;  import   barCss   from   style!css!bar.css ;  // good  import   fooSass   from   foo.scss ;  import   barCss   from   bar.css ;   \u2b06 back to top",
            "title": "Modules"
        },
        {
            "location": "/js/javascript/#iterators-and-generators",
            "text": "11.1  Don't use iterators. Prefer JavaScript's higher-order functions instead of loops like  for-in  or  for-of . eslint:  no-iterator   no-restricted-syntax    Why? This enforces our immutable rule. Dealing with pure functions that return values is easier to reason about than side effects.  Use  map()  /  every()  /  filter()  /  find()  /  findIndex()  /  reduce()  /  some()  / ... to iterate over arrays, and  Object.keys()  /  Object.values()  /  Object.entries()  to produce arrays so you can iterate over objects.   const   numbers   =   [ 1 ,   2 ,   3 ,   4 ,   5 ];  // bad  let   sum   =   0 ;  for   ( let   num   of   numbers )   { \n   sum   +=   num ;  }  sum   ===   15 ;  // good  let   sum   =   0 ;  numbers . forEach ( num   =   sum   +=   num );  sum   ===   15 ;  // best (use the functional force)  const   sum   =   numbers . reduce (( total ,   num )   =   total   +   num ,   0 );  sum   ===   15 ;  // bad  const   increasedByOne   =   [];  for   ( let   i   =   0 ;   i     numbers . length ;   i ++ )   { \n   increasedByOne . push ( numbers [ i ]   +   1 );  }  // good  const   increasedByOne   =   [];  numbers . forEach ( num   =   increasedByOne . push ( num   +   1 ));  // best (keeping it functional)  const   increasedByOne   =   numbers . map ( num   =   num   +   1 );    11.2  Don't use generators for now.    Why? They don't transpile well to ES5.    11.3  If you must use generators, or if you disregard  our advice , make sure their function signature is spaced properly. eslint:  generator-star-spacing    Why?  function  and  *  are part of the same conceptual keyword -  *  is not a modifier for  function ,  function*  is a unique construct, different from  function .   // bad  function   *   foo ()   { \n   // ...  }  // bad  const   bar   =   function   *   ()   { \n   // ...  };  // bad  const   baz   =   function   * ()   { \n   // ...  };  // bad  const   quux   =   function * ()   { \n   // ...  };  // bad  function * foo ()   { \n   // ...  }  // bad  function   * foo ()   { \n   // ...  }  // very bad  function  *  foo ()   { \n   // ...  }  // very bad  const   wat   =   function  *  ()   { \n   // ...  };  // good  function *   foo ()   { \n   // ...  }  // good  const   foo   =   function *   ()   { \n   // ...  };   \u2b06 back to top",
            "title": "Iterators and Generators"
        },
        {
            "location": "/js/javascript/#properties",
            "text": "12.1  Use dot notation when accessing properties. eslint:  dot-notation  jscs:  requireDotNotation   const   luke   =   { \n   jedi :   true , \n   age :   28 ,  };  // bad  const   isJedi   =   luke [ jedi ];  // good  const   isJedi   =   luke . jedi ;    12.2  Use bracket notation  []  when accessing properties with a variable.   const   luke   =   { \n   jedi :   true , \n   age :   28 ,  };  function   getProp ( prop )   { \n   return   luke [ prop ];  }  const   isJedi   =   getProp ( jedi );   \u2b06 back to top",
            "title": "Properties"
        },
        {
            "location": "/js/javascript/#variables",
            "text": "13.1  Always use  const  to declare variables. Not doing so will result in global variables. We want to avoid polluting the global namespace. Captain Planet warned us of that. eslint:  no-undef   prefer-const   // bad  superPower   =   new   SuperPower ();  // good  const   superPower   =   new   SuperPower ();    13.2  Use one  const  declaration per variable. eslint:  one-var  jscs:  disallowMultipleVarDecl    Why? It's easier to add new variable declarations this way, and you never have to worry about swapping out a  ;  for a  ,  or introducing punctuation-only diffs. You can also step through each declaration with the debugger, instead of jumping through all of them at once.   // bad  const   items   =   getItems (), \n     goSportsTeam   =   true , \n     dragonball   =   z ;  // bad  // (compare to above, and try to spot the mistake)  const   items   =   getItems (), \n     goSportsTeam   =   true ; \n     dragonball   =   z ;  // good  const   items   =   getItems ();  const   goSportsTeam   =   true ;  const   dragonball   =   z ;    13.3  Group all your  const s and then group all your  let s.    Why? This is helpful when later on you might need to assign a variable depending on one of the previous assigned variables.   // bad  let   i ,   len ,   dragonball , \n     items   =   getItems (), \n     goSportsTeam   =   true ;  // bad  let   i ;  const   items   =   getItems ();  let   dragonball ;  const   goSportsTeam   =   true ;  let   len ;  // good  const   goSportsTeam   =   true ;  const   items   =   getItems ();  let   dragonball ;  let   i ;  let   length ;    13.4  Assign variables where you need them, but place them in a reasonable place.    Why?  let  and  const  are block scoped and not function scoped.   // bad - unnecessary function call  function   checkName ( hasName )   { \n   const   name   =   getName (); \n\n   if   ( hasName   ===   test )   { \n     return   false ; \n   } \n\n   if   ( name   ===   test )   { \n     this . setName ( ); \n     return   false ; \n   } \n\n   return   name ;  }  // good  function   checkName ( hasName )   { \n   if   ( hasName   ===   test )   { \n     return   false ; \n   } \n\n   const   name   =   getName (); \n\n   if   ( name   ===   test )   { \n     this . setName ( ); \n     return   false ; \n   } \n\n   return   name ;  }    Don't chain variable assignments.  Chaining variable assignments creates implicit global variables.   // bad  ( function   example ()   { \n   // JavaScript interprets this as \n   // let a = ( b = ( c = 1 ) ); \n   // The let keyword only applies to variable a; variables b and c become \n   // global variables. \n   let   a   =   b   =   c   =   1 ;  }());  console . log ( a );   // undefined  console . log ( b );   // 1  console . log ( c );   // 1  // good  ( function   example ()   { \n   let   a   =   1 ; \n   let   b   =   a ; \n   let   c   =   a ;  }());  console . log ( a );   // undefined  console . log ( b );   // undefined  console . log ( c );   // undefined  // the same applies for `const`    13.6  Avoid using unary increments and decrements (++, --). eslint  no-plusplus    Why? Per the eslint documentation, unary increment and decrement statements are subject to automatic semicolon insertion and can cause silent errors with incrementing or decrementing values within an application. It is also more expressive to mutate your values with statements like  num += 1  instead of  num++  or  num ++ . Disallowing unary increment and decrement statements also prevents you from pre-incrementing/pre-decrementing values unintentionally which can also cause unexpected behavior in your programs.   // bad  let   array   =   [ 1 ,   2 ,   3 ];  let   num   =   1 ;  num ++ ;  -- num ;  let   sum   =   0 ;  let   truthyCount   =   0 ;  for   ( let   i   =   0 ;   i     array . length ;   i ++ )   { \n   let   value   =   array [ i ]; \n   sum   +=   value ; \n   if   ( value )   { \n     truthyCount ++ ; \n   }  }  // good  let   array   =   [ 1 ,   2 ,   3 ];  let   num   =   1 ;  num   +=   1 ;  num   -=   1 ;  const   sum   =   array . reduce (( a ,   b )   =   a   +   b ,   0 );  const   truthyCount   =   array . filter ( Boolean ). length ;   \u2b06 back to top",
            "title": "Variables"
        },
        {
            "location": "/js/javascript/#hoisting",
            "text": "14.1   var  declarations get hoisted to the top of their scope, their assignment does not.  const  and  let  declarations are blessed with a new concept called  Temporal Dead Zones (TDZ) . It's important to know why  typeof is no longer safe .   // we know this wouldn t work (assuming there  // is no notDefined global variable)  function   example ()   { \n   console . log ( notDefined );   // =  throws a ReferenceError  }  // creating a variable declaration after you  // reference the variable will work due to  // variable hoisting. Note: the assignment  // value of `true` is not hoisted.  function   example ()   { \n   console . log ( declaredButNotAssigned );   // =  undefined \n   var   declaredButNotAssigned   =   true ;  }  // the interpreter is hoisting the variable  // declaration to the top of the scope,  // which means our example could be rewritten as:  function   example ()   { \n   let   declaredButNotAssigned ; \n   console . log ( declaredButNotAssigned );   // =  undefined \n   declaredButNotAssigned   =   true ;  }  // using const and let  function   example ()   { \n   console . log ( declaredButNotAssigned );   // =  throws a ReferenceError \n   console . log ( typeof   declaredButNotAssigned );   // =  throws a ReferenceError \n   const   declaredButNotAssigned   =   true ;  }    14.2  Anonymous function expressions hoist their variable name, but not the function assignment.   function   example ()   { \n   console . log ( anonymous );   // =  undefined \n\n   anonymous ();   // =  TypeError anonymous is not a function \n\n   var   anonymous   =   function   ()   { \n     console . log ( anonymous function expression ); \n   };  }    14.3  Named function expressions hoist the variable name, not the function name or the function body.   function   example ()   { \n   console . log ( named );   // =  undefined \n\n   named ();   // =  TypeError named is not a function \n\n   superPower ();   // =  ReferenceError superPower is not defined \n\n   var   named   =   function   superPower ()   { \n     console . log ( Flying ); \n   };  }  // the same is true when the function name  // is the same as the variable name.  function   example ()   { \n   console . log ( named );   // =  undefined \n\n   named ();   // =  TypeError named is not a function \n\n   var   named   =   function   named ()   { \n     console . log ( named ); \n   };  }    14.4  Function declarations hoist their name and the function body.   function   example ()   { \n   superPower ();   // =  Flying \n\n   function   superPower ()   { \n     console . log ( Flying ); \n   }  }    For more information refer to  JavaScript Scoping   Hoisting  by  Ben Cherry .   \u2b06 back to top",
            "title": "Hoisting"
        },
        {
            "location": "/js/javascript/#comparison-operators-equality",
            "text": "15.1  Use  ===  and  !==  over  ==  and  != . eslint:  eqeqeq    15.2  Conditional statements such as the  if  statement evaluate their expression using coercion with the  ToBoolean  abstract method and always follow these simple rules:    Objects  evaluate to  true   Undefined  evaluates to  false  Null  evaluates to  false  Booleans  evaluate to  the value of the boolean  Numbers  evaluate to  false  if  +0, -0, or NaN , otherwise  true  Strings  evaluate to  false  if an empty string  '' , otherwise  true   if   ([ 0 ]     [])   { \n   // true \n   // an array (even an empty one) is an object, objects will evaluate to true  }    15.3  Use shortcuts for booleans, but explicit comparisons for strings and numbers.   // bad  if   ( isValid   ===   true )   { \n   // ...  }  // good  if   ( isValid )   { \n   // ...  }  // bad  if   ( name )   { \n   // ...  }  // good  if   ( name   !==   )   { \n   // ...  }  // bad  if   ( collection . length )   { \n   // ...  }  // good  if   ( collection . length     0 )   { \n   // ...  }     15.4  For more information see  Truth Equality and JavaScript  by Angus Croll.    15.5  Use braces to create blocks in  case  and  default  clauses that contain lexical declarations (e.g.  let ,  const ,  function , and  class ).     Why? Lexical declarations are visible in the entire  switch  block but only get initialized when assigned, which only happens when its  case  is reached. This causes problems when multiple  case  clauses attempt to define the same thing.   eslint rules:  no-case-declarations .  // bad  switch   ( foo )   { \n   case   1 : \n     let   x   =   1 ; \n     break ; \n   case   2 : \n     const   y   =   2 ; \n     break ; \n   case   3 : \n     function   f ()   { \n       // ... \n     } \n     break ; \n   default : \n     class   C   {}  }  // good  switch   ( foo )   { \n   case   1 :   { \n     let   x   =   1 ; \n     break ; \n   } \n   case   2 :   { \n     const   y   =   2 ; \n     break ; \n   } \n   case   3 :   { \n     function   f ()   { \n       // ... \n     } \n     break ; \n   } \n   case   4 : \n     bar (); \n     break ; \n   default :   { \n     class   C   {} \n   }  }    15.6  Ternaries should not be nested and generally be single line expressions.   eslint rules:  no-nested-ternary .  // bad  const   foo   =   maybe1     maybe2 \n   ?   bar \n   :   value1     value2   ?   baz   :   null ;  // better  const   maybeNull   =   value1     value2   ?   baz   :   null ;  const   foo   =   maybe1     maybe2 \n   ?   bar \n   :   maybeNull ;  // best  const   maybeNull   =   value1     value2   ?   baz   :   null ;  const   foo   =   maybe1     maybe2   ?   bar   :   maybeNull ;    15.7  Avoid unneeded ternary statements.   eslint rules:  no-unneeded-ternary .  // bad  const   foo   =   a   ?   a   :   b ;  const   bar   =   c   ?   true   :   false ;  const   baz   =   c   ?   false   :   true ;  // good  const   foo   =   a   ||   b ;  const   bar   =   !! c ;  const   baz   =   ! c ;   \u2b06 back to top",
            "title": "Comparison Operators &amp; Equality"
        },
        {
            "location": "/js/javascript/#blocks",
            "text": "16.1  Use braces with all multi-line blocks.   // bad  if   ( test ) \n   return   false ;  // good  if   ( test )   return   false ;  // good  if   ( test )   { \n   return   false ;  }  // bad  function   foo ()   {   return   false ;   }  // good  function   bar ()   { \n   return   false ;  }    16.2  If you're using multi-line blocks with  if  and  else , put  else  on the same line as your  if  block's closing brace. eslint:  brace-style  jscs:   disallowNewlineBeforeBlockStatements   // bad  if   ( test )   { \n   thing1 (); \n   thing2 ();  }  else   { \n   thing3 ();  }  // good  if   ( test )   { \n   thing1 (); \n   thing2 ();  }   else   { \n   thing3 ();  }   \u2b06 back to top",
            "title": "Blocks"
        },
        {
            "location": "/js/javascript/#comments",
            "text": "17.1  Use  /** ... */  for multi-line comments.   // bad  // make() returns a new element  // based on the passed in tag name  //  // @param {String} tag  // @return {Element} element  function   make ( tag )   { \n\n   // ... \n\n   return   element ;  }  // good  /**   * make() returns a new element   * based on the passed-in tag name   */  function   make ( tag )   { \n\n   // ... \n\n   return   element ;  }    17.2  Use  //  for single line comments. Place single line comments on a newline above the subject of the comment. Put an empty line before the comment unless it's on the first line of a block.   // bad  const   active   =   true ;    // is current tab  // good  // is current tab  const   active   =   true ;  // bad  function   getType ()   { \n   console . log ( fetching type... ); \n   // set the default type to  no type \n   const   type   =   this . type   ||   no type ; \n\n   return   type ;  }  // good  function   getType ()   { \n   console . log ( fetching type... ); \n\n   // set the default type to  no type \n   const   type   =   this . type   ||   no type ; \n\n   return   type ;  }  // also good  function   getType ()   { \n   // set the default type to  no type \n   const   type   =   this . type   ||   no type ; \n\n   return   type ;  }    17.3  Start all comments with a space to make it easier to read. eslint:  spaced-comment   // bad  //is current tab  const   active   =   true ;  // good  // is current tab  const   active   =   true ;  // bad  /**   *make() returns a new element   *based on the passed-in tag name   */  function   make ( tag )   { \n\n   // ... \n\n   return   element ;  }  // good  /**   * make() returns a new element   * based on the passed-in tag name   */  function   make ( tag )   { \n\n   // ... \n\n   return   element ;  }     17.4  Prefixing your comments with  FIXME  or  TODO  helps other developers quickly understand if you're pointing out a problem that needs to be revisited, or if you're suggesting a solution to the problem that needs to be implemented. These are different than regular comments because they are actionable. The actions are  FIXME: -- need to figure this out  or  TODO: -- need to implement .    17.5  Use  // FIXME:  to annotate problems.    class   Calculator   extends   Abacus   { \n   constructor ()   { \n     super (); \n\n     // FIXME: shouldn t use a global here \n     total   =   0 ; \n   }  }    17.6  Use  // TODO:  to annotate solutions to problems.   class   Calculator   extends   Abacus   { \n   constructor ()   { \n     super (); \n\n     // TODO: total should be configurable by an options param \n     this . total   =   0 ; \n   }  }   \u2b06 back to top",
            "title": "Comments"
        },
        {
            "location": "/js/javascript/#whitespace",
            "text": "18.1  Use soft tabs set to 2 spaces. eslint:  indent  jscs:  validateIndentation   // bad  function   foo ()   {  \u2219\u2219\u2219\u2219 let   name ;  }  // bad  function   bar ()   {  \u2219 let   name ;  }  // good  function   baz ()   {  \u2219\u2219 let   name ;  }    18.2  Place 1 space before the leading brace. eslint:  space-before-blocks  jscs:  requireSpaceBeforeBlockStatements   // bad  function   test (){ \n   console . log ( test );  }  // good  function   test ()   { \n   console . log ( test );  }  // bad  dog . set ( attr ,{ \n   age :   1 year , \n   breed :   Bernese Mountain Dog ,  });  // good  dog . set ( attr ,   { \n   age :   1 year , \n   breed :   Bernese Mountain Dog ,  });    18.3  Place 1 space before the opening parenthesis in control statements ( if ,  while  etc.). Place no space between the argument list and the function name in function calls and declarations. eslint:  keyword-spacing  jscs:  requireSpaceAfterKeywords   // bad  if ( isJedi )   { \n   fight   ();  }  // good  if   ( isJedi )   { \n   fight ();  }  // bad  function   fight   ()   { \n   console . log   ( Swooosh! );  }  // good  function   fight ()   { \n   console . log ( Swooosh! );  }    18.4  Set off operators with spaces. eslint:  space-infix-ops  jscs:  requireSpaceBeforeBinaryOperators ,  requireSpaceAfterBinaryOperators   // bad  const   x = y + 5 ;  // good  const   x   =   y   +   5 ;    18.5  End files with a single newline character. eslint:  eol-last   // bad  import   {   es6   }   from   ./AirbnbStyleGuide ; \n   // ...  export   default   es6 ;   // bad  import   {   es6   }   from   ./AirbnbStyleGuide ; \n   // ...  export   default   es6 ; \u21b5  \u21b5   // good  import   {   es6   }   from   ./AirbnbStyleGuide ; \n   // ...  export   default   es6 ; \u21b5    18.6  Use indentation when making long method chains (more than 2 method chains). Use a leading dot, which\nemphasizes that the line is a method call, not a new statement. eslint:  newline-per-chained-call   no-whitespace-before-property   // bad  $ ( #items ). find ( .selected ). highlight (). end (). find ( .open ). updateCount ();  // bad  $ ( #items ). \n   find ( .selected ). \n     highlight (). \n     end (). \n   find ( .open ). \n     updateCount ();  // good  $ ( #items ) \n   . find ( .selected ) \n     . highlight () \n     . end () \n   . find ( .open ) \n     . updateCount ();  // bad  const   leds   =   stage . selectAll ( .led ). data ( data ). enter (). append ( svg:svg ). classed ( led ,   true ) \n     . attr ( width ,   ( radius   +   margin )   *   2 ). append ( svg:g ) \n     . attr ( transform ,   `translate( ${ radius   +   margin } , ${ radius   +   margin } )` ) \n     . call ( tron . led );  // good  const   leds   =   stage . selectAll ( .led ) \n     . data ( data ) \n   . enter (). append ( svg:svg ) \n     . classed ( led ,   true ) \n     . attr ( width ,   ( radius   +   margin )   *   2 ) \n   . append ( svg:g ) \n     . attr ( transform ,   `translate( ${ radius   +   margin } , ${ radius   +   margin } )` ) \n     . call ( tron . led );  // good  const   leds   =   stage . selectAll ( .led ). data ( data );    18.7  Leave a blank line after blocks and before the next statement. jscs:  requirePaddingNewLinesAfterBlocks   // bad  if   ( foo )   { \n   return   bar ;  }  return   baz ;  // good  if   ( foo )   { \n   return   bar ;  }  return   baz ;  // bad  const   obj   =   { \n   foo ()   { \n   }, \n   bar ()   { \n   },  };  return   obj ;  // good  const   obj   =   { \n   foo ()   { \n   }, \n\n   bar ()   { \n   },  };  return   obj ;  // bad  const   arr   =   [ \n   function   foo ()   { \n   }, \n   function   bar ()   { \n   },  ];  return   arr ;  // good  const   arr   =   [ \n   function   foo ()   { \n   }, \n\n   function   bar ()   { \n   },  ];  return   arr ;    18.8  Do not pad your blocks with blank lines. eslint:  padded-blocks  jscs:   disallowPaddingNewlinesInBlocks   // bad  function   bar ()   { \n\n   console . log ( foo );  }  // also bad  if   ( baz )   { \n\n   console . log ( qux );  }   else   { \n   console . log ( foo );  }  // good  function   bar ()   { \n   console . log ( foo );  }  // good  if   ( baz )   { \n   console . log ( qux );  }   else   { \n   console . log ( foo );  }    18.9  Do not add spaces inside parentheses. eslint:  space-in-parens  jscs:  disallowSpacesInsideParentheses   // bad  function   bar (   foo   )   { \n   return   foo ;  }  // good  function   bar ( foo )   { \n   return   foo ;  }  // bad  if   (   foo   )   { \n   console . log ( foo );  }  // good  if   ( foo )   { \n   console . log ( foo );  }    18.10  Do not add spaces inside brackets. eslint:  array-bracket-spacing  jscs:  disallowSpacesInsideArrayBrackets   // bad  const   foo   =   [   1 ,   2 ,   3   ];  console . log ( foo [   0   ]);  // good  const   foo   =   [ 1 ,   2 ,   3 ];  console . log ( foo [ 0 ]);    18.11  Add spaces inside curly braces. eslint:  object-curly-spacing  jscs:  requireSpacesInsideObjectBrackets   // bad  const   foo   =   { clark :   kent };  // good  const   foo   =   {   clark :   kent   };    18.12  Avoid having lines of code that are longer than 100 characters (including whitespace). Note: per  above , long strings are exempt from this rule, and should not be broken up. eslint:  max-len  jscs:  maximumLineLength    Why? This ensures readability and maintainability.   // bad  const   foo   =   jsonData     jsonData . foo     jsonData . foo . bar     jsonData . foo . bar . baz     jsonData . foo . bar . baz . quux     jsonData . foo . bar . baz . quux . xyzzy ;  // bad  $ . ajax ({   method :   POST ,   url :   https://airbnb.com/ ,   data :   {   name :   John   }   }). done (()   =   console . log ( Congratulations! )). fail (()   =   console . log ( You have failed this city. ));  // good  const   foo   =   jsonData \n     jsonData . foo \n     jsonData . foo . bar \n     jsonData . foo . bar . baz \n     jsonData . foo . bar . baz . quux \n     jsonData . foo . bar . baz . quux . xyzzy ;  // good  $ . ajax ({ \n   method :   POST , \n   url :   https://airbnb.com/ , \n   data :   {   name :   John   },  }) \n   . done (()   =   console . log ( Congratulations! )) \n   . fail (()   =   console . log ( You have failed this city. ));   \u2b06 back to top",
            "title": "Whitespace"
        },
        {
            "location": "/js/javascript/#commas",
            "text": "19.1  Leading commas:  Nope . eslint:  comma-style  jscs:  requireCommaBeforeLineBreak   // bad  const   story   =   [ \n     once \n   ,   upon \n   ,   aTime  ];  // good  const   story   =   [ \n   once , \n   upon , \n   aTime ,  ];  // bad  const   hero   =   { \n     firstName :   Ada \n   ,   lastName :   Lovelace \n   ,   birthYear :   1815 \n   ,   superPower :   computers  };  // good  const   hero   =   { \n   firstName :   Ada , \n   lastName :   Lovelace , \n   birthYear :   1815 , \n   superPower :   computers ,  };    19.2  Additional trailing comma:  Yup.  eslint:  comma-dangle  jscs:  requireTrailingComma    Why? This leads to cleaner git diffs. Also, transpilers like Babel will remove the additional trailing comma in the transpiled code which means you don't have to worry about the  trailing comma problem  in legacy browsers.   // bad - git diff without trailing comma\nconst hero = {\n     firstName:  Florence , -    lastName:  Nightingale  +    lastName:  Nightingale ,  +    inventorOf: [ coxcomb chart ,  modern nursing ] \n};\n\n// good - git diff with trailing comma\nconst hero = {\n     firstName:  Florence ,\n     lastName:  Nightingale , +    inventorOf: [ coxcomb chart ,  modern nursing ], \n};  // bad  const   hero   =   { \n   firstName :   Dana , \n   lastName :   Scully  };  const   heroes   =   [ \n   Batman , \n   Superman  ];  // good  const   hero   =   { \n   firstName :   Dana , \n   lastName :   Scully ,  };  const   heroes   =   [ \n   Batman , \n   Superman ,  ];  // bad  function   createHero ( \n   firstName , \n   lastName , \n   inventorOf  )   { \n   // does nothing  }  // good  function   createHero ( \n   firstName , \n   lastName , \n   inventorOf ,  )   { \n   // does nothing  }  // good (note that a comma must not appear after a  rest  element)  function   createHero ( \n   firstName , \n   lastName , \n   inventorOf , \n   ... heroArgs  )   { \n   // does nothing  }  // bad  createHero ( \n   firstName , \n   lastName , \n   inventorOf  );  // good  createHero ( \n   firstName , \n   lastName , \n   inventorOf ,  );  // good (note that a comma must not appear after a  rest  element)  createHero ( \n   firstName , \n   lastName , \n   inventorOf , \n   ... heroArgs  );   \u2b06 back to top",
            "title": "Commas"
        },
        {
            "location": "/js/javascript/#semicolons",
            "text": "20.1   Yup.  eslint:  semi  jscs:  requireSemicolons   // bad  ( function   ()   { \n   const   name   =   Skywalker \n   return   name  })()  // good  ( function   ()   { \n   const   name   =   Skywalker ; \n   return   name ;  }());  // good, but legacy (guards against the function becoming an argument when two files with IIFEs are concatenated)  ;((()   =   { \n   const   name   =   Skywalker ; \n   return   name ;  })());   Read more .  \u2b06 back to top",
            "title": "Semicolons"
        },
        {
            "location": "/js/javascript/#type-casting-coercion",
            "text": "21.1  Perform type coercion at the beginning of the statement.    21.2   Strings:    // =  this.reviewScore = 9;  // bad  const   totalScore   =   this . reviewScore   +   ;   // invokes this.reviewScore.valueOf()  // bad  const   totalScore   =   this . reviewScore . toString ();   // isn t guaranteed to return a string  // good  const   totalScore   =   String ( this . reviewScore );    21.3  Numbers: Use  Number  for type casting and  parseInt  always with a radix for parsing strings. eslint:  radix   const   inputValue   =   4 ;  // bad  const   val   =   new   Number ( inputValue );  // bad  const   val   =   + inputValue ;  // bad  const   val   =   inputValue     0 ;  // bad  const   val   =   parseInt ( inputValue );  // good  const   val   =   Number ( inputValue );  // good  const   val   =   parseInt ( inputValue ,   10 );    21.4  If for whatever reason you are doing something wild and  parseInt  is your bottleneck and need to use Bitshift for  performance reasons , leave a comment explaining why and what you're doing.   // good  /**   * parseInt was the reason my code was slow.   * Bitshifting the String to coerce it to a   * Number made it a lot faster.   */  const   val   =   inputValue     0 ;    21.5  Be careful when using bitshift operations.  Numbers are represented as  64-bit values , but  bitshift operations always return a 32-bit integer ( source ). Bitshift can lead to unexpected behavior for integer values larger than 32 bits.  Discussion . Largest signed 32-bit Int is 2,147,483,647:   2147483647     0 ;   // =  2147483647  2147483648     0 ;   // =  -2147483648  2147483649     0 ;   // =  -2147483647    21.6  Booleans:   const   age   =   0 ;  // bad  const   hasAge   =   new   Boolean ( age );  // good  const   hasAge   =   Boolean ( age );  // best  const   hasAge   =   !! age ;   \u2b06 back to top",
            "title": "Type Casting &amp; Coercion"
        },
        {
            "location": "/js/javascript/#naming-conventions",
            "text": "22.1  Avoid single letter names. Be descriptive with your naming. eslint:  id-length   // bad  function   q ()   { \n   // ...  }  // good  function   query ()   { \n   // ...  }    22.2  Use camelCase when naming objects, functions, and instances. eslint:  camelcase  jscs:  requireCamelCaseOrUpperCaseIdentifiers   // bad  const   OBJEcttsssss   =   {};  const   this_is_my_object   =   {};  function   c ()   {}  // good  const   thisIsMyObject   =   {};  function   thisIsMyFunction ()   {}    22.3  Use PascalCase only when naming constructors or classes. eslint:  new-cap  jscs:  requireCapitalizedConstructors   // bad  function   user ( options )   { \n   this . name   =   options . name ;  }  const   bad   =   new   user ({ \n   name :   nope ,  });  // good  class   User   { \n   constructor ( options )   { \n     this . name   =   options . name ; \n   }  }  const   good   =   new   User ({ \n   name :   yup ,  });   \n-  22.4  Do not use trailing or leading underscores. eslint:  no-underscore-dangle  jscs:  disallowDanglingUnderscores   Why? JavaScript does not have the concept of privacy in terms of properties or methods. Although a leading underscore is a common convention to mean \u201cprivate\u201d, in fact, these properties are fully public, and as such, are part of your public API contract. This convention might lead developers to wrongly think that a change won't count as breaking, or that tests aren't needed. tl;dr: if you want something to be \u201cprivate\u201d, it must not be observably present.   // bad  this . __firstName__   =   Panda ;  this . firstName_   =   Panda ;  this . _firstName   =   Panda ;  // good  this . firstName   =   Panda ;   \n-  22.5  Don't save references to  this . Use arrow functions or  Function#bind . jscs:  disallowNodeTypes  // bad  function   foo ()   { \n   const   self   =   this ; \n   return   function   ()   { \n     console . log ( self ); \n   };  }  // bad  function   foo ()   { \n   const   that   =   this ; \n   return   function   ()   { \n     console . log ( that ); \n   };  }  // good  function   foo ()   { \n   return   ()   =   { \n     console . log ( this ); \n   };  }   \n-  22.6  A base filename should exactly match the name of its default export.  // file 1 contents  class   CheckBox   { \n   // ...  }  export   default   CheckBox ;  // file 2 contents  export   default   function   fortyTwo ()   {   return   42 ;   }  // file 3 contents  export   default   function   insideDirectory ()   {}  // in some other file  // bad  import   CheckBox   from   ./checkBox ;   // PascalCase import/export, camelCase filename  import   FortyTwo   from   ./FortyTwo ;   // PascalCase import/filename, camelCase export  import   InsideDirectory   from   ./InsideDirectory ;   // PascalCase import/filename, camelCase export  // bad  import   CheckBox   from   ./check_box ;   // PascalCase import/export, snake_case filename  import   forty_two   from   ./forty_two ;   // snake_case import/filename, camelCase export  import   inside_directory   from   ./inside_directory ;   // snake_case import, camelCase export  import   index   from   ./inside_directory/index ;   // requiring the index file explicitly  import   insideDirectory   from   ./insideDirectory/index ;   // requiring the index file explicitly  // good  import   CheckBox   from   ./CheckBox ;   // PascalCase export/import/filename  import   fortyTwo   from   ./fortyTwo ;   // camelCase export/import/filename  import   insideDirectory   from   ./insideDirectory ;   // camelCase export/import/directory name/implicit  index  // ^ supports both insideDirectory.js and insideDirectory/index.js   \n-  22.7  Use camelCase when you export-default a function. Your filename should be identical to your function's name.  function   makeStyleGuide ()   { \n   // ...  }  export   default   makeStyleGuide ;   \n-  22.8  Use PascalCase when you export a constructor / class / singleton / function library / bare object.  const   AirbnbStyleGuide   =   { \n   es6 :   { \n   },  };  export   default   AirbnbStyleGuide ;   \n-  22.9  Acronyms and initialisms should always be all capitalized, or all lowercased.   Why? Names are for readability, not to appease a computer algorithm.   // bad  import   SmsContainer   from   ./containers/SmsContainer ;  // bad  const   HttpRequests   =   [ \n   // ...  ];  // good  import   SMSContainer   from   ./containers/SMSContainer ;  // good  const   HTTPRequests   =   [ \n   // ...  ];  // best  import   TextMessageContainer   from   ./containers/TextMessageContainer ;  // best  const   Requests   =   [ \n   // ...  ];   \u2b06 back to top",
            "title": "Naming Conventions"
        },
        {
            "location": "/js/javascript/#accessors",
            "text": "-  23.1  Accessor functions for properties are not required.  \n-  23.2  Do not use JavaScript getters/setters as they cause unexpected side effects and are harder to test, maintain, and reason about. Instead, if you do make accessor functions, use getVal() and setVal('hello').  // bad  class   Dragon   { \n   get   age ()   { \n     // ... \n   } \n\n   set   age ( value )   { \n     // ... \n   }  }  // good  class   Dragon   { \n   getAge ()   { \n     // ... \n   } \n\n   setAge ( value )   { \n     // ... \n   }  }   \n-  23.3  If the property/method is a  boolean , use  isVal()  or  hasVal() .  // bad  if   ( ! dragon . age ())   { \n   return   false ;  }  // good  if   ( ! dragon . hasAge ())   { \n   return   false ;  }   \n-  23.4  It's okay to create get() and set() functions, but be consistent.  class   Jedi   { \n   constructor ( options   =   {})   { \n     const   lightsaber   =   options . lightsaber   ||   blue ; \n     this . set ( lightsaber ,   lightsaber ); \n   } \n\n   set ( key ,   val )   { \n     this [ key ]   =   val ; \n   } \n\n   get ( key )   { \n     return   this [ key ]; \n   }  }   \u2b06 back to top",
            "title": "Accessors"
        },
        {
            "location": "/js/javascript/#events",
            "text": "-  24.1  When attaching data payloads to events (whether DOM events or something more proprietary like Backbone events), pass a hash instead of a raw value. This allows a subsequent contributor to add more data to the event payload without finding and updating every handler for the event. For example, instead of:  // bad  $ ( this ). trigger ( listingUpdated ,   listing . id );  // ...  $ ( this ). on ( listingUpdated ,   ( e ,   listingId )   =   { \n   // do something with listingId  });   prefer:  // good  $ ( this ). trigger ( listingUpdated ,   {   listingId :   listing . id   });  // ...  $ ( this ). on ( listingUpdated ,   ( e ,   data )   =   { \n   // do something with data.listingId  });   \u2b06 back to top",
            "title": "Events"
        },
        {
            "location": "/js/javascript/#ecmascript-6-es-2015-styles",
            "text": "27.1  This is a collection of links to the various ES6 features.    Arrow Functions   Classes  Object Shorthand  Object Concise  Object Computed Properties  Template Strings  Destructuring  Default Parameters  Rest  Array Spreads  Let and Const  Iterators and Generators  Modules    Do not use  TC39 proposals  that have not reached stage 3.  They are not finalized , and they are subject to change or to be withdrawn entirely. We want to use JavaScript, and proposals are not JavaScript yet.   \u2b06 back to top",
            "title": "ECMAScript 6+ (ES 2015+) Styles"
        },
        {
            "location": "/js/javascript/#testing",
            "text": "28.1   Yup.   function   foo ()   { \n   return   true ;  }    28.2   No, but seriously :  Whichever testing framework you use, you should be writing tests!  Strive to write many small pure functions, and minimize where mutations occur.  Be cautious about stubs and mocks - they can make your tests more brittle.  We primarily use  mocha  at Airbnb.  tape  is also used occasionally for small, separate modules.  100% test coverage is a good goal to strive for, even if it's not always practical to reach it.  Whenever you fix a bug,  write a regression test . A bug fixed without a regression test is almost certainly going to break again in the future.     \u2b06 back to top",
            "title": "Testing"
        },
        {
            "location": "/js/javascript/#performance",
            "text": "On Layout   Web Performance  String vs Array Concat  Try/Catch Cost In a Loop  Bang Function  jQuery Find vs Context, Selector  innerHTML vs textContent for script text  Long String Concatenation  Are Javascript functions like  map() ,  reduce() , and  filter()  optimized for traversing arrays?  Loading...   \u2b06 back to top",
            "title": "Performance"
        },
        {
            "location": "/js/javascript/#resources",
            "text": "Learning ES6   Draft ECMA 2015 (ES6) Spec  ExploringJS  ES6 Compatibility Table  Comprehensive Overview of ES6 Features   Read This   Standard ECMA-262   Tools   Code Style Linters  ESlint  -  Airbnb Style .eslintrc  JSHint  -  Airbnb Style .jshintrc  JSCS  -  Airbnb Style Preset   Other Style Guides   Google JavaScript Style Guide  jQuery Core Style Guidelines  Principles of Writing Consistent, Idiomatic JavaScript   Other Styles   Naming this in nested functions  - Christian Johansen  Conditional Callbacks  - Ross Allen  Popular JavaScript Coding Conventions on GitHub  - JeongHoon Byun  Multiple var statements in JavaScript, not superfluous  - Ben Alman   Further Reading   Understanding JavaScript Closures  - Angus Croll  Basic JavaScript for the impatient programmer  - Dr. Axel Rauschmayer  You Might Not Need jQuery  - Zack Bloom   Adam Schwartz  ES6 Features  - Luke Hoban  Frontend Guidelines  - Benjamin De Cock   Books   JavaScript: The Good Parts  - Douglas Crockford  JavaScript Patterns  - Stoyan Stefanov  Pro JavaScript Design Patterns   - Ross Harmes and Dustin Diaz  High Performance Web Sites: Essential Knowledge for Front-End Engineers  - Steve Souders  Maintainable JavaScript  - Nicholas C. Zakas  JavaScript Web Applications  - Alex MacCaw  Pro JavaScript Techniques  - John Resig  Smashing Node.js: JavaScript Everywhere  - Guillermo Rauch  Secrets of the JavaScript Ninja  - John Resig and Bear Bibeault  Human JavaScript  - Henrik Joreteg  Superhero.js  - Kim Joar Bekkelund, Mads Mob\u00e6k,   Olav Bjorkoy  JSBooks  - Julien Bouquillon  Third Party JavaScript  - Ben Vinegar and Anton Kovalyov  Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript  - David Herman  Eloquent JavaScript  - Marijn Haverbeke  You Don't Know JS: ES6   Beyond  - Kyle Simpson   Blogs   JavaScript Weekly  JavaScript, JavaScript...  Bocoup Weblog  Adequately Good  NCZOnline  Perfection Kills  Ben Alman  Dmitry Baranovskiy  Dustin Diaz  nettuts   Podcasts   JavaScript Air  JavaScript Jabber   \u2b06 back to top",
            "title": "Resources"
        },
        {
            "location": "/js/react/",
            "text": "Venngage React/JSX Style Guide\n\n\nA mostly reasonable approach to React and JSX\n\n\nTable of Contents\n\n\n\n\nBasic Rules\n\n\nClass vs \nReact.createClass\n vs stateless\n\n\nNaming\n\n\nDeclaration\n\n\nAlignment\n\n\nQuotes\n\n\nSpacing\n\n\nProps\n\n\nRefs\n\n\nParentheses\n\n\nTags\n\n\nMethods\n\n\nOrdering\n\n\nisMounted\n\n\n\n\nBasic Rules\n\n\n\n\nOnly include one React component per file.\n\n\nHowever, multiple \nStateless, or Pure, Components\n are allowed per file. eslint: \nreact/no-multi-comp\n.\n\n\nAlways use JSX syntax.\n\n\nDo not use \nReact.createElement\n unless you're initializing the app from a file that is not JSX.\n\n\n\n\nClass vs \nReact.createClass\n vs stateless\n\n\n\n\nIf you have internal state and/or refs, prefer \nclass extends React.Component\n over \nReact.createClass\n unless you have a very good reason to use mixins. eslint: \nreact/prefer-es6-class\n \nreact/prefer-stateless-function\n\n\n\n\n// bad\nconst Listing = React.createClass({\n  // ...\n  render() {\n    return \ndiv\n{this.state.hello}\n/div\n;\n  }\n});\n\n// good\nclass Listing extends React.Component {\n  // ...\n  render() {\n    return \ndiv\n{this.state.hello}\n/div\n;\n  }\n}\n\n\n\n\n\nAnd if you don't have state or refs, prefer normal functions (not arrow functions) over classes:\n\n\n// bad\nclass Listing extends React.Component {\n  render() {\n    return \ndiv\n{this.props.hello}\n/div\n;\n  }\n}\n\n// bad (relying on function name inference is discouraged)\nconst Listing = ({ hello }) =\n (\n  \ndiv\n{hello}\n/div\n\n);\n\n// good\nfunction Listing({ hello }) {\n  return \ndiv\n{hello}\n/div\n;\n}\n\n\n\n\n\nNaming\n\n\n\n\nExtensions\n: Use \n.jsx\n extension for React components.\n\n\nFilename\n: Use PascalCase for filenames. E.g., \nReservationCard.jsx\n.\n\n\nReference Naming\n: Use PascalCase for React components and camelCase for their instances. eslint: \nreact/jsx-pascal-case\n\n\n\n\n// bad\nimport reservationCard from \n./ReservationCard\n;\n\n// good\nimport ReservationCard from \n./ReservationCard\n;\n\n// bad\nconst ReservationItem = \nReservationCard /\n;\n\n// good\nconst reservationItem = \nReservationCard /\n;\n\n\n\n\n\n\n\nComponent Naming\n: Use the filename as the component name. For example, \nReservationCard.jsx\n should have a reference name of \nReservationCard\n. However, for root components of a directory, use \nindex.jsx\n as the filename and use the directory name as the component name:\n\n\n\n\n// bad\nimport Footer from \n./Footer/Footer\n;\n\n// bad\nimport Footer from \n./Footer/index\n;\n\n// good\nimport Footer from \n./Footer\n;\n\n\n\n\n\n\n\nHigher-order Component Naming\n: Use a composite of the higher-order component's name and the passed-in component's name as the \ndisplayName\n on the generated component. For example, the higher-order component \nwithFoo()\n, when passed a component \nBar\n should produce a component with a \ndisplayName\n of \nwithFoo(Bar)\n.\n\n\n\n\n\n\nWhy? A component's \ndisplayName\n may be used by developer tools or in error messages, and having a value that clearly expresses this relationship helps people understand what is happening.\n\n\n\n\n// bad\nexport default function withFoo(WrappedComponent) {\n  return function WithFoo(props) {\n    return \nWrappedComponent {...props} foo /\n;\n  }\n}\n\n// good\nexport default function withFoo(WrappedComponent) {\n  function WithFoo(props) {\n    return \nWrappedComponent {...props} foo /\n;\n  }\n\n  const wrappedComponentName = WrappedComponent.displayName\n    || WrappedComponent.name\n    || \nComponent\n;\n\n  WithFoo.displayName = `withFoo(${wrappedComponentName})`;\n  return WithFoo;\n}\n\n\n\n\n\n\n\nProps Naming\n: Avoid using DOM component prop names for different purposes.\n\n\n\n\n\n\nWhy? People expect props like \nstyle\n and \nclassName\n to mean one specific thing. Varying this API for a subset of your app makes the code less readable and less maintainable, and may cause bugs.\n\n\n\n\n// bad\n\nMyComponent style=\nfancy\n /\n\n\n// good\n\nMyComponent variant=\nfancy\n /\n\n\n\n\n\n\nDeclaration\n\n\n\n\nDo not use \ndisplayName\n for naming components. Instead, name the component by reference.\n\n\n\n\n// bad\nexport default React.createClass({\n  displayName: \nReservationCard\n,\n  // stuff goes here\n});\n\n// good\nexport default class ReservationCard extends React.Component {\n}\n\n\n\n\n\nAlignment\n\n\n\n\nFollow these alignment styles for JSX syntax. eslint: \nreact/jsx-closing-bracket-location\n\n\n\n\n// bad\n\nFoo superLongParam=\nbar\n\n     anotherSuperLongParam=\nbaz\n /\n\n\n// good\n\nFoo\n  superLongParam=\nbar\n\n  anotherSuperLongParam=\nbaz\n\n/\n\n\n// if props fit in one line then keep it on the same line\n\nFoo bar=\nbar\n /\n\n\n// children get indented normally\n\nFoo\n  superLongParam=\nbar\n\n  anotherSuperLongParam=\nbaz\n\n\n\n  \nQuux /\n\n\n/Foo\n\n\n\n\n\n\nQuotes\n\n\n\n\nAlways use double quotes (\n\"\n) for JSX attributes, but single quotes (\n'\n) for all other JS. eslint: \njsx-quotes\n\n\n\n\n\n\nWhy? Regular HTML attributes also typically use double quotes instead of single, so JSX attributes mirror this convention.\n\n\n\n\n// bad\n\nFoo bar=\nbar\n /\n\n\n// good\n\nFoo bar=\nbar\n /\n\n\n// bad\n\nFoo style={{ left: \n20px\n }} /\n\n\n// good\n\nFoo style={{ left: \n20px\n }} /\n\n\n\n\n\n\nSpacing\n\n\n\n\nAlways include a single space in your self-closing tag. eslint: \nno-multi-spaces\n, \nreact/jsx-space-before-closing\n\n\n\n\n// bad\n\nFoo/\n\n\n// very bad\n\nFoo                 /\n\n\n// bad\n\nFoo\n /\n\n\n// good\n\nFoo /\n\n\n\n\n\n\n\n\nDo not pad JSX curly braces with spaces. eslint: \nreact/jsx-curly-spacing\n\n\n\n\n// bad\n\nFoo bar={ baz } /\n\n\n// good\n\nFoo bar={baz} /\n\n\n\n\n\n\nProps\n\n\n\n\nAlways use camelCase for prop names.\n\n\n\n\n  // bad\n  \nFoo\n    UserName=\nhello\n\n    phone_number={12345678}\n  /\n\n\n  // good\n  \nFoo\n    userName=\nhello\n\n    phoneNumber={12345678}\n  /\n\n\n\n\n\n\n\n\nOmit the value of the prop when it is explicitly \ntrue\n. eslint: \nreact/jsx-boolean-value\n\n\n\n\n  // bad\n  \nFoo\n    hidden={true}\n  /\n\n\n  // good\n  \nFoo\n    hidden\n  /\n\n\n\n\n\n\n\n\nAlways include an \nalt\n prop on \nimg\n tags. If the image is presentational, \nalt\n can be an empty string or the \nimg\n must have \nrole=\"presentation\"\n. eslint: \njsx-a11y/img-has-alt\n\n\n\n\n// bad\n\nimg src=\nhello.jpg\n /\n\n\n// good\n\nimg src=\nhello.jpg\n alt=\nMe waving hello\n /\n\n\n// good\n\nimg src=\nhello.jpg\n alt=\n /\n\n\n// good\n\nimg src=\nhello.jpg\n role=\npresentation\n /\n\n\n\n\n\n\n\n\nDo not use words like \"image\", \"photo\", or \"picture\" in \nimg\n \nalt\n props. eslint: \njsx-a11y/img-redundant-alt\n\n\n\n\n\n\nWhy? Screenreaders already announce \nimg\n elements as images, so there is no need to include this information in the alt text.\n\n\n\n\n// bad\n\nimg src=\nhello.jpg\n alt=\nPicture of me waving hello\n /\n\n\n// good\n\nimg src=\nhello.jpg\n alt=\nMe waving hello\n /\n\n\n\n\n\n\n\n\nUse only valid, non-abstract \nARIA roles\n. eslint: \njsx-a11y/aria-role\n\n\n\n\n// bad - not an ARIA role\n\ndiv role=\ndatepicker\n /\n\n\n// bad - abstract ARIA role\n\ndiv role=\nrange\n /\n\n\n// good\n\ndiv role=\nbutton\n /\n\n\n\n\n\n\n\n\nDo not use \naccessKey\n on elements. eslint: \njsx-a11y/no-access-key\n\n\n\n\n\n\nWhy? Inconsistencies between keyboard shortcuts and keyboard commands used by people using screenreaders and keyboards complicate accessibility.\n\n\n\n\n// bad\n\ndiv accessKey=\nh\n /\n\n\n// good\n\ndiv /\n\n\n\n\n\n\n\n\nAvoid using an array index as \nkey\n prop, prefer a unique ID. (\nwhy?\n)\n\n\n\n\n// bad\n{todos.map((todo, index) =\n\n\nTodo\n  {...todo}\n  key={index}\n/\n\n)}\n\n// good\n{todos.map(todo =\n (\n\nTodo\n  {...todo}\n  key={todo.id}\n/\n\n))}\n\n\n\n\n\n\n\nAlways define explicit defaultProps for all non-required props.\n\n\n\n\n\n\nWhy? propTypes are a form of documentation, and providing defaultProps means the reader of your code doesn\u2019t have to assume as much. In addition, it can mean that your code can omit certain type checks.\n\n\n\n\n// bad\nfunction SFC({ foo, bar, children }) {\nreturn \ndiv\n{foo}{bar}{children}\n/div\n;\n}\nSFC.propTypes = {\nfoo: PropTypes.number.isRequired,\nbar: PropTypes.string,\nchildren: PropTypes.node,\n};\n\n// good\nfunction SFC({ foo, bar }) {\nreturn \ndiv\n{foo}{bar}\n/div\n;\n}\nSFC.propTypes = {\nfoo: PropTypes.number.isRequired,\nbar: PropTypes.string,\nchildren: PropTypes.node,\n};\nSFC.defaultProps = {\nbar: \n,\nchildren: null,\n};\n\n\n\n\n\nRefs\n\n\n\n\nAlways use ref callbacks. eslint: \nreact/no-string-refs\n\n\n\n\n// bad\n\nFoo\n  ref=\nmyRef\n\n/\n\n\n// good\n\nFoo\n  ref={(ref) =\n { this.myRef = ref; }}\n/\n\n\n\n\n\n\nParentheses\n\n\n\n\nWrap JSX tags in parentheses when they span more than one line. eslint: \nreact/wrap-multilines\n\n\n\n\n// bad\nrender() {\n  return \nMyComponent className=\nlong body\n foo=\nbar\n\n           \nMyChild /\n\n         \n/MyComponent\n;\n}\n\n// good\nrender() {\n  return (\n    \nMyComponent className=\nlong body\n foo=\nbar\n\n      \nMyChild /\n\n    \n/MyComponent\n\n  );\n}\n\n// good, when single line\nrender() {\n  const body = \ndiv\nhello\n/div\n;\n  return \nMyComponent\n{body}\n/MyComponent\n;\n}\n\n\n\n\n\nTags\n\n\n\n\nAlways self-close tags that have no children. eslint: \nreact/self-closing-comp\n\n\n\n\n// bad\n\nFoo className=\nstuff\n/Foo\n\n\n// good\n\nFoo className=\nstuff\n /\n\n\n\n\n\n\n\n\nIf your component has multi-line properties, close its tag on a new line. eslint: \nreact/jsx-closing-bracket-location\n\n\n\n\n// bad\n\nFoo\n  bar=\nbar\n\n  baz=\nbaz\n /\n\n\n// good\n\nFoo\n  bar=\nbar\n\n  baz=\nbaz\n\n/\n\n\n\n\n\n\nMethods\n\n\n\n\nUse arrow functions to close over local variables.\n\n\n\n\nfunction ItemList(props) {\n  return (\n    \nul\n\n      {props.items.map((item, index) =\n (\n        \nItem\n          key={item.key}\n          onClick={() =\n doSomethingWith(item.name, index)}\n        /\n\n      ))}\n    \n/ul\n\n  );\n}\n\n\n\n\n\n\n\nBind event handlers for the render method in the constructor. eslint: \nreact/jsx-no-bind\n\n\n\n\n\n\nWhy? A bind call in the render path creates a brand new function on every single render.\n\n\n\n\n// bad\nclass extends React.Component {\n  onClickDiv() {\n    // do stuff\n  }\n\n  render() {\n    return \ndiv onClick={this.onClickDiv.bind(this)} /\n\n  }\n}\n\n// good\nclass extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.onClickDiv = this.onClickDiv.bind(this);\n  }\n\n  onClickDiv() {\n    // do stuff\n  }\n\n  render() {\n    return \ndiv onClick={this.onClickDiv} /\n\n  }\n}\n\n\n\n\n\n\n\nDo not use underscore prefix for internal methods of a React component.\n\n\nWhy? Underscore prefixes are sometimes used as a convention in other languages to denote privacy. But, unlike those languages, there is no native support for privacy in JavaScript, everything is public. Regardless of your intentions, adding underscore prefixes to your properties does not actually make them private, and any property (underscore-prefixed or not) should be treated as being public. See issues \n#1024\n, and \n#490\n for a more in-depth discussion.\n\n\n\n\n\n\n\n\n// bad\nReact.createClass({\n  _onClickSubmit() {\n    // do stuff\n  },\n\n  // other stuff\n});\n\n// good\nclass extends React.Component {\n  onClickSubmit() {\n    // do stuff\n  }\n\n  // other stuff\n}\n\n\n\n\n\n\n\nBe sure to return a value in your \nrender\n methods. eslint: \nreact/require-render-return\n\n\n\n\n// bad\nrender() {\n  (\ndiv /\n);\n}\n\n// good\nrender() {\n  return (\ndiv /\n);\n}\n\n\n\n\n\nOrdering\n\n\n\n\nOrdering for \nclass extends React.Component\n:\n\n\n\n\noptional \nstatic\n methods\n\n\nconstructor\n\n\ngetChildContext\n\n\ncomponentWillMount\n\n\ncomponentDidMount\n\n\ncomponentWillReceiveProps\n\n\nshouldComponentUpdate\n\n\ncomponentWillUpdate\n\n\ncomponentDidUpdate\n\n\ncomponentWillUnmount\n\n\nclickHandlers or eventHandlers\n like \nonClickSubmit()\n or \nonChangeDescription()\n\n\ngetter methods for \nrender\n like \ngetSelectReason()\n or \ngetFooterContent()\n\n\noptional render methods\n like \nrenderNavigation()\n or \nrenderProfilePicture()\n\n\n\n\nrender\n\n\n\n\n\n\nHow to define \npropTypes\n, \ndefaultProps\n, \ncontextTypes\n, etc...\n\n\n\n\n\n\nimport React, { PropTypes } from \nreact\n;\n\nconst propTypes = {\n  id: PropTypes.number.isRequired,\n  url: PropTypes.string.isRequired,\n  text: PropTypes.string,\n};\n\nconst defaultProps = {\n  text: \nHello World\n,\n};\n\nclass Link extends React.Component {\n  static methodsAreOk() {\n    return true;\n  }\n\n  render() {\n    return \na href={this.props.url} data-id={this.props.id}\n{this.props.text}\n/a\n\n  }\n}\n\nLink.propTypes = propTypes;\nLink.defaultProps = defaultProps;\n\nexport default Link;\n\n\n\n\n\nOrdering for \nReact.createClass\n: eslint: \nreact/sort-comp\n\n\n\n\ndisplayName\n\n\npropTypes\n\n\ncontextTypes\n\n\nchildContextTypes\n\n\nmixins\n\n\nstatics\n\n\ndefaultProps\n\n\ngetDefaultProps\n\n\ngetInitialState\n\n\ngetChildContext\n\n\ncomponentWillMount\n\n\ncomponentDidMount\n\n\ncomponentWillReceiveProps\n\n\nshouldComponentUpdate\n\n\ncomponentWillUpdate\n\n\ncomponentDidUpdate\n\n\ncomponentWillUnmount\n\n\nclickHandlers or eventHandlers\n like \nonClickSubmit()\n or \nonChangeDescription()\n\n\ngetter methods for \nrender\n like \ngetSelectReason()\n or \ngetFooterContent()\n\n\noptional render methods\n like \nrenderNavigation()\n or \nrenderProfilePicture()\n\n\nrender\n\n\n\n\nisMounted\n\n\n\n\nDo not use \nisMounted\n. eslint: \nreact/no-is-mounted\n\n\n\n\n\n\nWhy? \nisMounted\n is an anti-pattern\n, is not available when using ES6 classes, and is on its way to being officially deprecated.\n\n\n\n\n\u2b06 back to top",
            "title": "React"
        },
        {
            "location": "/js/react/#venngage-reactjsx-style-guide",
            "text": "A mostly reasonable approach to React and JSX",
            "title": "Venngage React/JSX Style Guide"
        },
        {
            "location": "/js/react/#table-of-contents",
            "text": "Basic Rules  Class vs  React.createClass  vs stateless  Naming  Declaration  Alignment  Quotes  Spacing  Props  Refs  Parentheses  Tags  Methods  Ordering  isMounted",
            "title": "Table of Contents"
        },
        {
            "location": "/js/react/#basic-rules",
            "text": "Only include one React component per file.  However, multiple  Stateless, or Pure, Components  are allowed per file. eslint:  react/no-multi-comp .  Always use JSX syntax.  Do not use  React.createElement  unless you're initializing the app from a file that is not JSX.",
            "title": "Basic Rules"
        },
        {
            "location": "/js/react/#class-vs-reactcreateclass-vs-stateless",
            "text": "If you have internal state and/or refs, prefer  class extends React.Component  over  React.createClass  unless you have a very good reason to use mixins. eslint:  react/prefer-es6-class   react/prefer-stateless-function   // bad\nconst Listing = React.createClass({\n  // ...\n  render() {\n    return  div {this.state.hello} /div ;\n  }\n});\n\n// good\nclass Listing extends React.Component {\n  // ...\n  render() {\n    return  div {this.state.hello} /div ;\n  }\n}  And if you don't have state or refs, prefer normal functions (not arrow functions) over classes:  // bad\nclass Listing extends React.Component {\n  render() {\n    return  div {this.props.hello} /div ;\n  }\n}\n\n// bad (relying on function name inference is discouraged)\nconst Listing = ({ hello }) =  (\n   div {hello} /div \n);\n\n// good\nfunction Listing({ hello }) {\n  return  div {hello} /div ;\n}",
            "title": "Class vs React.createClass vs stateless"
        },
        {
            "location": "/js/react/#naming",
            "text": "Extensions : Use  .jsx  extension for React components.  Filename : Use PascalCase for filenames. E.g.,  ReservationCard.jsx .  Reference Naming : Use PascalCase for React components and camelCase for their instances. eslint:  react/jsx-pascal-case   // bad\nimport reservationCard from  ./ReservationCard ;\n\n// good\nimport ReservationCard from  ./ReservationCard ;\n\n// bad\nconst ReservationItem =  ReservationCard / ;\n\n// good\nconst reservationItem =  ReservationCard / ;   Component Naming : Use the filename as the component name. For example,  ReservationCard.jsx  should have a reference name of  ReservationCard . However, for root components of a directory, use  index.jsx  as the filename and use the directory name as the component name:   // bad\nimport Footer from  ./Footer/Footer ;\n\n// bad\nimport Footer from  ./Footer/index ;\n\n// good\nimport Footer from  ./Footer ;   Higher-order Component Naming : Use a composite of the higher-order component's name and the passed-in component's name as the  displayName  on the generated component. For example, the higher-order component  withFoo() , when passed a component  Bar  should produce a component with a  displayName  of  withFoo(Bar) .    Why? A component's  displayName  may be used by developer tools or in error messages, and having a value that clearly expresses this relationship helps people understand what is happening.   // bad\nexport default function withFoo(WrappedComponent) {\n  return function WithFoo(props) {\n    return  WrappedComponent {...props} foo / ;\n  }\n}\n\n// good\nexport default function withFoo(WrappedComponent) {\n  function WithFoo(props) {\n    return  WrappedComponent {...props} foo / ;\n  }\n\n  const wrappedComponentName = WrappedComponent.displayName\n    || WrappedComponent.name\n    ||  Component ;\n\n  WithFoo.displayName = `withFoo(${wrappedComponentName})`;\n  return WithFoo;\n}   Props Naming : Avoid using DOM component prop names for different purposes.    Why? People expect props like  style  and  className  to mean one specific thing. Varying this API for a subset of your app makes the code less readable and less maintainable, and may cause bugs.   // bad MyComponent style= fancy  / \n\n// good MyComponent variant= fancy  /",
            "title": "Naming"
        },
        {
            "location": "/js/react/#declaration",
            "text": "Do not use  displayName  for naming components. Instead, name the component by reference.   // bad\nexport default React.createClass({\n  displayName:  ReservationCard ,\n  // stuff goes here\n});\n\n// good\nexport default class ReservationCard extends React.Component {\n}",
            "title": "Declaration"
        },
        {
            "location": "/js/react/#alignment",
            "text": "Follow these alignment styles for JSX syntax. eslint:  react/jsx-closing-bracket-location   // bad Foo superLongParam= bar \n     anotherSuperLongParam= baz  / \n\n// good Foo\n  superLongParam= bar \n  anotherSuperLongParam= baz \n/ \n\n// if props fit in one line then keep it on the same line Foo bar= bar  / \n\n// children get indented normally Foo\n  superLongParam= bar \n  anotherSuperLongParam= baz  \n   Quux /  /Foo",
            "title": "Alignment"
        },
        {
            "location": "/js/react/#quotes",
            "text": "Always use double quotes ( \" ) for JSX attributes, but single quotes ( ' ) for all other JS. eslint:  jsx-quotes    Why? Regular HTML attributes also typically use double quotes instead of single, so JSX attributes mirror this convention.   // bad Foo bar= bar  / \n\n// good Foo bar= bar  / \n\n// bad Foo style={{ left:  20px  }} / \n\n// good Foo style={{ left:  20px  }} /",
            "title": "Quotes"
        },
        {
            "location": "/js/react/#spacing",
            "text": "Always include a single space in your self-closing tag. eslint:  no-multi-spaces ,  react/jsx-space-before-closing   // bad Foo/ \n\n// very bad Foo                 / \n\n// bad Foo\n / \n\n// good Foo /    Do not pad JSX curly braces with spaces. eslint:  react/jsx-curly-spacing   // bad Foo bar={ baz } / \n\n// good Foo bar={baz} /",
            "title": "Spacing"
        },
        {
            "location": "/js/react/#props",
            "text": "Always use camelCase for prop names.     // bad\n   Foo\n    UserName= hello \n    phone_number={12345678}\n  / \n\n  // good\n   Foo\n    userName= hello \n    phoneNumber={12345678}\n  /    Omit the value of the prop when it is explicitly  true . eslint:  react/jsx-boolean-value     // bad\n   Foo\n    hidden={true}\n  / \n\n  // good\n   Foo\n    hidden\n  /    Always include an  alt  prop on  img  tags. If the image is presentational,  alt  can be an empty string or the  img  must have  role=\"presentation\" . eslint:  jsx-a11y/img-has-alt   // bad img src= hello.jpg  / \n\n// good img src= hello.jpg  alt= Me waving hello  / \n\n// good img src= hello.jpg  alt=  / \n\n// good img src= hello.jpg  role= presentation  /    Do not use words like \"image\", \"photo\", or \"picture\" in  img   alt  props. eslint:  jsx-a11y/img-redundant-alt    Why? Screenreaders already announce  img  elements as images, so there is no need to include this information in the alt text.   // bad img src= hello.jpg  alt= Picture of me waving hello  / \n\n// good img src= hello.jpg  alt= Me waving hello  /    Use only valid, non-abstract  ARIA roles . eslint:  jsx-a11y/aria-role   // bad - not an ARIA role div role= datepicker  / \n\n// bad - abstract ARIA role div role= range  / \n\n// good div role= button  /    Do not use  accessKey  on elements. eslint:  jsx-a11y/no-access-key    Why? Inconsistencies between keyboard shortcuts and keyboard commands used by people using screenreaders and keyboards complicate accessibility.   // bad div accessKey= h  / \n\n// good div /    Avoid using an array index as  key  prop, prefer a unique ID. ( why? )   // bad\n{todos.map((todo, index) =  Todo\n  {...todo}\n  key={index}\n/ \n)}\n\n// good\n{todos.map(todo =  ( Todo\n  {...todo}\n  key={todo.id}\n/ \n))}   Always define explicit defaultProps for all non-required props.    Why? propTypes are a form of documentation, and providing defaultProps means the reader of your code doesn\u2019t have to assume as much. In addition, it can mean that your code can omit certain type checks.   // bad\nfunction SFC({ foo, bar, children }) {\nreturn  div {foo}{bar}{children} /div ;\n}\nSFC.propTypes = {\nfoo: PropTypes.number.isRequired,\nbar: PropTypes.string,\nchildren: PropTypes.node,\n};\n\n// good\nfunction SFC({ foo, bar }) {\nreturn  div {foo}{bar} /div ;\n}\nSFC.propTypes = {\nfoo: PropTypes.number.isRequired,\nbar: PropTypes.string,\nchildren: PropTypes.node,\n};\nSFC.defaultProps = {\nbar:  ,\nchildren: null,\n};",
            "title": "Props"
        },
        {
            "location": "/js/react/#refs",
            "text": "Always use ref callbacks. eslint:  react/no-string-refs   // bad Foo\n  ref= myRef \n/ \n\n// good Foo\n  ref={(ref) =  { this.myRef = ref; }}\n/",
            "title": "Refs"
        },
        {
            "location": "/js/react/#parentheses",
            "text": "Wrap JSX tags in parentheses when they span more than one line. eslint:  react/wrap-multilines   // bad\nrender() {\n  return  MyComponent className= long body  foo= bar \n            MyChild / \n          /MyComponent ;\n}\n\n// good\nrender() {\n  return (\n     MyComponent className= long body  foo= bar \n       MyChild / \n     /MyComponent \n  );\n}\n\n// good, when single line\nrender() {\n  const body =  div hello /div ;\n  return  MyComponent {body} /MyComponent ;\n}",
            "title": "Parentheses"
        },
        {
            "location": "/js/react/#tags",
            "text": "Always self-close tags that have no children. eslint:  react/self-closing-comp   // bad Foo className= stuff /Foo \n\n// good Foo className= stuff  /    If your component has multi-line properties, close its tag on a new line. eslint:  react/jsx-closing-bracket-location   // bad Foo\n  bar= bar \n  baz= baz  / \n\n// good Foo\n  bar= bar \n  baz= baz \n/",
            "title": "Tags"
        },
        {
            "location": "/js/react/#methods",
            "text": "Use arrow functions to close over local variables.   function ItemList(props) {\n  return (\n     ul \n      {props.items.map((item, index) =  (\n         Item\n          key={item.key}\n          onClick={() =  doSomethingWith(item.name, index)}\n        / \n      ))}\n     /ul \n  );\n}   Bind event handlers for the render method in the constructor. eslint:  react/jsx-no-bind    Why? A bind call in the render path creates a brand new function on every single render.   // bad\nclass extends React.Component {\n  onClickDiv() {\n    // do stuff\n  }\n\n  render() {\n    return  div onClick={this.onClickDiv.bind(this)} / \n  }\n}\n\n// good\nclass extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.onClickDiv = this.onClickDiv.bind(this);\n  }\n\n  onClickDiv() {\n    // do stuff\n  }\n\n  render() {\n    return  div onClick={this.onClickDiv} / \n  }\n}   Do not use underscore prefix for internal methods of a React component.  Why? Underscore prefixes are sometimes used as a convention in other languages to denote privacy. But, unlike those languages, there is no native support for privacy in JavaScript, everything is public. Regardless of your intentions, adding underscore prefixes to your properties does not actually make them private, and any property (underscore-prefixed or not) should be treated as being public. See issues  #1024 , and  #490  for a more in-depth discussion.     // bad\nReact.createClass({\n  _onClickSubmit() {\n    // do stuff\n  },\n\n  // other stuff\n});\n\n// good\nclass extends React.Component {\n  onClickSubmit() {\n    // do stuff\n  }\n\n  // other stuff\n}   Be sure to return a value in your  render  methods. eslint:  react/require-render-return   // bad\nrender() {\n  ( div / );\n}\n\n// good\nrender() {\n  return ( div / );\n}",
            "title": "Methods"
        },
        {
            "location": "/js/react/#ordering",
            "text": "Ordering for  class extends React.Component :   optional  static  methods  constructor  getChildContext  componentWillMount  componentDidMount  componentWillReceiveProps  shouldComponentUpdate  componentWillUpdate  componentDidUpdate  componentWillUnmount  clickHandlers or eventHandlers  like  onClickSubmit()  or  onChangeDescription()  getter methods for  render  like  getSelectReason()  or  getFooterContent()  optional render methods  like  renderNavigation()  or  renderProfilePicture()   render    How to define  propTypes ,  defaultProps ,  contextTypes , etc...    import React, { PropTypes } from  react ;\n\nconst propTypes = {\n  id: PropTypes.number.isRequired,\n  url: PropTypes.string.isRequired,\n  text: PropTypes.string,\n};\n\nconst defaultProps = {\n  text:  Hello World ,\n};\n\nclass Link extends React.Component {\n  static methodsAreOk() {\n    return true;\n  }\n\n  render() {\n    return  a href={this.props.url} data-id={this.props.id} {this.props.text} /a \n  }\n}\n\nLink.propTypes = propTypes;\nLink.defaultProps = defaultProps;\n\nexport default Link;  Ordering for  React.createClass : eslint:  react/sort-comp   displayName  propTypes  contextTypes  childContextTypes  mixins  statics  defaultProps  getDefaultProps  getInitialState  getChildContext  componentWillMount  componentDidMount  componentWillReceiveProps  shouldComponentUpdate  componentWillUpdate  componentDidUpdate  componentWillUnmount  clickHandlers or eventHandlers  like  onClickSubmit()  or  onChangeDescription()  getter methods for  render  like  getSelectReason()  or  getFooterContent()  optional render methods  like  renderNavigation()  or  renderProfilePicture()  render",
            "title": "Ordering"
        },
        {
            "location": "/js/react/#ismounted",
            "text": "Do not use  isMounted . eslint:  react/no-is-mounted    Why?  isMounted  is an anti-pattern , is not available when using ES6 classes, and is on its way to being officially deprecated.   \u2b06 back to top",
            "title": "isMounted"
        },
        {
            "location": "/js/css-js/",
            "text": "Venngage CSS-in-JavaScript Style Guide\n\n\n\n\nNaming\n\n\nOrdering\n\n\nNesting\n\n\nInline\n\n\nThemes\n\n\n\n\nNaming\n\n\n\n\nUse camelCase for object keys (i.e. \"selectors\").\n\n\n\n\n\n\nWhy? We access these keys as properties on the \nstyles\n object in the component, so it is most convenient to use camelCase.\n\n\n\n\n// bad\n\n\n{\n\n  \nbermuda-triangle\n:\n \n{\n\n    \ndisplay\n:\n \nnone\n,\n\n  \n},\n\n\n}\n\n\n\n// good\n\n\n{\n\n  \nbermudaTriangle\n:\n \n{\n\n    \ndisplay\n:\n \nnone\n,\n\n  \n},\n\n\n}\n\n\n\n\n\n\n\n\nUse an underscore for modifiers to other styles.\n\n\n\n\n\n\nWhy? Similar to BEM, this naming convention makes it clear that the styles are intended to modify the element preceded by the underscore. Underscores do not need to be quoted, so they are preferred over other characters, such as dashes.\n\n\n\n\n// bad\n\n\n{\n\n  \nbruceBanner\n:\n \n{\n\n    \ncolor\n:\n \npink\n,\n\n    \ntransition\n:\n \ncolor 10s\n,\n\n  \n},\n\n\n  \nbruceBannerTheHulk\n:\n \n{\n\n    \ncolor\n:\n \ngreen\n,\n\n  \n},\n\n\n}\n\n\n\n// good\n\n\n{\n\n  \nbruceBanner\n:\n \n{\n\n    \ncolor\n:\n \npink\n,\n\n    \ntransition\n:\n \ncolor 10s\n,\n\n  \n},\n\n\n  \nbruceBanner_theHulk\n:\n \n{\n\n    \ncolor\n:\n \ngreen\n,\n\n  \n},\n\n\n}\n\n\n\n\n\n\n\n\nUse \nselectorName_fallback\n for sets of fallback styles.\n\n\n\n\n\n\nWhy? Similar to modifiers, keeping the naming consistent helps reveal the relationship of these styles to the styles that override them in more adequate browsers.\n\n\n\n\n// bad\n\n\n{\n\n  \nmuscles\n:\n \n{\n\n    \ndisplay\n:\n \nflex\n,\n\n  \n},\n\n\n  \nmuscles_sadBears\n:\n \n{\n\n    \nwidth\n:\n \n100%\n,\n\n  \n},\n\n\n}\n\n\n\n// good\n\n\n{\n\n  \nmuscles\n:\n \n{\n\n    \ndisplay\n:\n \nflex\n,\n\n  \n},\n\n\n  \nmuscles_fallback\n:\n \n{\n\n    \nwidth\n:\n \n100%\n,\n\n  \n},\n\n\n}\n\n\n\n\n\n\n\n\nUse a separate selector for sets of fallback styles.\n\n\n\n\n\n\nWhy? Keeping fallback styles contained in a separate object clarifies their purpose, which improves readability.\n\n\n\n\n// bad\n\n\n{\n\n  \nmuscles\n:\n \n{\n\n    \ndisplay\n:\n \nflex\n,\n\n  \n},\n\n\n  \nleft\n:\n \n{\n\n    \nflexGrow\n:\n \n1\n,\n\n    \ndisplay\n:\n \ninline-block\n,\n\n  \n},\n\n\n  \nright\n:\n \n{\n\n    \ndisplay\n:\n \ninline-block\n,\n\n  \n},\n\n\n}\n\n\n\n// good\n\n\n{\n\n  \nmuscles\n:\n \n{\n\n    \ndisplay\n:\n \nflex\n,\n\n  \n},\n\n\n  \nleft\n:\n \n{\n\n    \nflexGrow\n:\n \n1\n,\n\n  \n},\n\n\n  \nleft_fallback\n:\n \n{\n\n    \ndisplay\n:\n \ninline-block\n,\n\n  \n},\n\n\n  \nright_fallback\n:\n \n{\n\n    \ndisplay\n:\n \ninline-block\n,\n\n  \n},\n\n\n}\n\n\n\n\n\n\n\n\nUse device-agnostic names (e.g. \"small\", \"medium\", and \"large\") to name media query breakpoints.\n\n\n\n\n\n\nWhy? Commonly used names like \"phone\", \"tablet\", and \"desktop\" do not match the characteristics of the devices in the real world. Using these names sets the wrong expectations.\n\n\n\n\n// bad\n\n\nconst\n \nbreakpoints\n \n=\n \n{\n\n  \nmobile\n:\n \n@media (max-width: 639px)\n,\n\n  \ntablet\n:\n \n@media (max-width: 1047px)\n,\n\n  \ndesktop\n:\n \n@media (min-width: 1048px)\n,\n\n\n};\n\n\n\n// good\n\n\nconst\n \nbreakpoints\n \n=\n \n{\n\n  \nsmall\n:\n \n@media (max-width: 639px)\n,\n\n  \nmedium\n:\n \n@media (max-width: 1047px)\n,\n\n  \nlarge\n:\n \n@media (min-width: 1048px)\n,\n\n\n};\n\n\n\n\n\n\nOrdering\n\n\n\n\nDefine styles after the component.\n\n\n\n\n\n\nWhy? We use a higher-order component to theme our styles, which is naturally used after the component definition. Passing the styles object directly to this function reduces indirection.\n\n\n\n\n// bad\nconst styles = {\n  container: {\n    display: \ninline-block\n,\n  },\n};\n\nfunction MyComponent({ styles }) {\n  return (\n    \ndiv {...css(styles.container)}\n\n      Never doubt that a small group of thoughtful, committed citizens can\n      change the world. Indeed, it\u2019s the only thing that ever has.\n    \n/div\n\n  );\n}\n\nexport default withStyles(() =\n styles)(MyComponent);\n\n\n// good\nfunction MyComponent({ styles }) {\n  return (\n    \ndiv {...css(styles.container)}\n\n      Never doubt that a small group of thoughtful, committed citizens can\n      change the world. Indeed, it\u2019s the only thing that ever has.\n    \n/div\n\n  );\n}\n\nexport default withStyles(() =\n ({\n  container: {\n    display: \ninline-block\n,\n  },\n}))(MyComponent);\n\n\n\n\n\nNesting\n\n\n\n\nLeave a blank line between adjacent blocks at the same indentation level.\n\n\n\n\n\n\nWhy? The whitespace improves readability and reduces the likelihood of merge conflicts.\n\n\n\n\n// bad\n\n\n{\n\n  \nbigBang\n:\n \n{\n\n    \ndisplay\n:\n \ninline-block\n,\n\n    \n::before\n:\n \n{\n\n      \ncontent\n:\n \n,\n\n    \n},\n\n  \n},\n\n  \nuniverse\n:\n \n{\n\n    \nborder\n:\n \nnone\n,\n\n  \n},\n\n\n}\n\n\n\n// good\n\n\n{\n\n  \nbigBang\n:\n \n{\n\n    \ndisplay\n:\n \ninline-block\n,\n\n\n    \n::before\n:\n \n{\n\n      \ncontent\n:\n \n,\n\n    \n},\n\n  \n},\n\n\n  \nuniverse\n:\n \n{\n\n    \nborder\n:\n \nnone\n,\n\n  \n},\n\n\n}\n\n\n\n\n\n\nInline\n\n\n\n\nUse inline styles for styles that have a high cardinality (e.g. uses the value of a prop) and not for styles that have a low cardinality.\n\n\n\n\n\n\nWhy? Generating themed stylesheets can be expensive, so they are best for discrete sets of styles.\n\n\n\n\n// bad\nexport default function MyComponent({ spacing }) {\n  return (\n    \ndiv style={{ display: \ntable\n, margin: spacing }} /\n\n  );\n}\n\n// good\nfunction MyComponent({ styles, spacing }) {\n  return (\n    \ndiv {...css(styles.periodic, { margin: spacing })} /\n\n  );\n}\nexport default withStyles(() =\n ({\n  periodic: {\n    display: \ntable\n,\n  },\n}))(MyComponent);\n\n\n\n\n\nThemes\n\n\n\n\nUse an abstraction layer such as \nreact-with-styles\n that enables theming. \nreact-with-styles gives us things like \nwithStyles()\n, \nThemedStyleSheet\n, and \ncss()\n which are used in some of the examples in this document.\n\n\n\n\n\n\nWhy? It is useful to have a set of shared variables for styling your components. Using an abstraction layer makes this more convenient. Additionally, this can help prevent your components from being tightly coupled to any particular underlying implementation, which gives you more freedom.\n\n\n\n\n\n\nDefine colors only in themes.\n\n\n\n\n// bad\n\n\nexport\n \ndefault\n \nwithStyles\n(()\n \n=\n \n({\n\n  \nchuckNorris\n:\n \n{\n\n    \ncolor\n:\n \n#bada55\n,\n\n  \n},\n\n\n}))(\nMyComponent\n);\n\n\n\n// good\n\n\nexport\n \ndefault\n \nwithStyles\n(({\n \ncolor\n \n})\n \n=\n \n({\n\n  \nchuckNorris\n:\n \n{\n\n    \ncolor\n:\n \ncolor\n.\nbadass\n,\n\n  \n},\n\n\n}))(\nMyComponent\n);\n\n\n\n\n\n\n\n\nDefine fonts only in themes.\n\n\n\n\n// bad\n\n\nexport\n \ndefault\n \nwithStyles\n(()\n \n=\n \n({\n\n  \ntowerOfPisa\n:\n \n{\n\n    \nfontStyle\n:\n \nitalic\n,\n\n  \n},\n\n\n}))(\nMyComponent\n);\n\n\n\n// good\n\n\nexport\n \ndefault\n \nwithStyles\n(({\n \nfont\n \n})\n \n=\n \n({\n\n  \ntowerOfPisa\n:\n \n{\n\n    \nfontStyle\n:\n \nfont\n.\nitalic\n,\n\n  \n},\n\n\n}))(\nMyComponent\n);\n\n\n\n\n\n\n\n\nDefine fonts as sets of related styles.\n\n\n\n\n// bad\n\n\nexport\n \ndefault\n \nwithStyles\n(()\n \n=\n \n({\n\n  \ntowerOfPisa\n:\n \n{\n\n    \nfontFamily\n:\n \nItaliana, \nTimes New Roman\n, serif\n,\n\n    \nfontSize\n:\n \n2em\n,\n\n    \nfontStyle\n:\n \nitalic\n,\n\n    \nlineHeight\n:\n \n1.5\n,\n\n  \n},\n\n\n}))(\nMyComponent\n);\n\n\n\n// good\n\n\nexport\n \ndefault\n \nwithStyles\n(({\n \nfont\n \n})\n \n=\n \n({\n\n  \ntowerOfPisa\n:\n \n{\n\n    \n...\nfont\n.\nitalian\n,\n\n  \n},\n\n\n}))(\nMyComponent\n);\n\n\n\n\n\n\n\n\nDefine base grid units in theme (either as a value or a function that takes a multiplier).\n\n\n\n\n// bad\n\n\nexport\n \ndefault\n \nwithStyles\n(()\n \n=\n \n({\n\n  \nrip\n:\n \n{\n\n    \nbottom\n:\n \n-6912px\n,\n \n// 6 feet\n\n  \n},\n\n\n}))(\nMyComponent\n);\n\n\n\n// good\n\n\nexport\n \ndefault\n \nwithStyles\n(({\n \nunits\n \n})\n \n=\n \n({\n\n  \nrip\n:\n \n{\n\n    \nbottom\n:\n \nunits\n(\n864\n),\n \n// 6 feet, assuming our unit is 8px\n\n  \n},\n\n\n}))(\nMyComponent\n);\n\n\n\n// good\n\n\nexport\n \ndefault\n \nwithStyles\n(({\n \nunit\n \n})\n \n=\n \n({\n\n  \nrip\n:\n \n{\n\n    \nbottom\n:\n \n864\n \n*\n \nunit\n,\n \n// 6 feet, assuming our unit is 8px\n\n  \n},\n\n\n}))(\nMyComponent\n);\n\n\n\n\n\n\n\n\nDefine media queries only in themes.\n\n\n\n\n// bad\n\n\nexport\n \ndefault\n \nwithStyles\n(()\n \n=\n \n({\n\n  \ncontainer\n:\n \n{\n\n    \nwidth\n:\n \n100%\n,\n\n\n    \n@media (max-width: 1047px)\n:\n \n{\n\n      \nwidth\n:\n \n50%\n,\n\n    \n},\n\n  \n},\n\n\n}))(\nMyComponent\n);\n\n\n\n// good\n\n\nexport\n \ndefault\n \nwithStyles\n(({\n \nbreakpoint\n \n})\n \n=\n \n({\n\n  \ncontainer\n:\n \n{\n\n    \nwidth\n:\n \n100%\n,\n\n\n    \n[\nbreakpoint\n.\nmedium\n]\n:\n \n{\n\n      \nwidth\n:\n \n50%\n,\n\n    \n},\n\n  \n},\n\n\n}))(\nMyComponent\n);\n\n\n\n\n\n\n\n\nDefine tricky fallback properties in themes.\n\n\n\n\n\n\nWhy? Many CSS-in-JavaScript implementations merge style objects together which makes specifying fallbacks for the same property (e.g. \ndisplay\n) a little tricky. To keep the approach unified, put these fallbacks in the theme.\n\n\n\n\n// bad\n\n\nexport\n \ndefault\n \nwithStyles\n(()\n \n=\n \n({\n\n  \n.\nmuscles\n \n{\n\n    \ndisplay\n:\n \nflex\n,\n\n  \n},\n\n\n  \n.\nmuscles_fallback\n \n{\n\n    \ndisplay \n:\n \ntable\n,\n\n  \n},\n\n\n}))(\nMyComponent\n);\n\n\n\n// good\n\n\nexport\n \ndefault\n \nwithStyles\n(({\n \nfallbacks\n \n})\n \n=\n \n({\n\n  \n.\nmuscles\n \n{\n\n    \ndisplay\n:\n \nflex\n,\n\n  \n},\n\n\n  \n.\nmuscles_fallback\n \n{\n\n    \n[\nfallbacks\n.\ndisplay\n]\n:\n \ntable\n,\n\n  \n},\n\n\n}))(\nMyComponent\n);\n\n\n\n// good\n\n\nexport\n \ndefault\n \nwithStyles\n(({\n \nfallback\n \n})\n \n=\n \n({\n\n  \n.\nmuscles\n \n{\n\n    \ndisplay\n:\n \nflex\n,\n\n  \n},\n\n\n  \n.\nmuscles_fallback\n \n{\n\n    \n[\nfallback\n(\ndisplay\n)]\n:\n \ntable\n,\n\n  \n},\n\n\n}))(\nMyComponent\n);\n\n\n\n\n\n\n\n\n\n\nCreate as few custom themes as possible. Many applications may only have one theme.\n\n\n\n\n\n\nNamespace custom theme settings under a nested object with a unique and descriptive key.\n\n\n\n\n\n\n// bad\n\n\nThemedStyleSheet\n.\nregisterTheme\n(\nmySection\n,\n \n{\n\n  \nmySectionPrimaryColor\n:\n \ngreen\n,\n\n\n});\n\n\n\n// good\n\n\nThemedStyleSheet\n.\nregisterTheme\n(\nmySection\n,\n \n{\n\n  \nmySection\n:\n \n{\n\n    \nprimaryColor\n:\n \ngreen\n,\n\n  \n},\n\n\n});\n\n\n\n\n\n\n\n\nCSS puns adapted from \nSaijo George\n.",
            "title": "CSS in Javascript"
        },
        {
            "location": "/js/css-js/#venngage-css-in-javascript-style-guide",
            "text": "Naming  Ordering  Nesting  Inline  Themes",
            "title": "Venngage CSS-in-JavaScript Style Guide"
        },
        {
            "location": "/js/css-js/#naming",
            "text": "Use camelCase for object keys (i.e. \"selectors\").    Why? We access these keys as properties on the  styles  object in the component, so it is most convenient to use camelCase.   // bad  { \n   bermuda-triangle :   { \n     display :   none , \n   },  }  // good  { \n   bermudaTriangle :   { \n     display :   none , \n   },  }    Use an underscore for modifiers to other styles.    Why? Similar to BEM, this naming convention makes it clear that the styles are intended to modify the element preceded by the underscore. Underscores do not need to be quoted, so they are preferred over other characters, such as dashes.   // bad  { \n   bruceBanner :   { \n     color :   pink , \n     transition :   color 10s , \n   }, \n\n   bruceBannerTheHulk :   { \n     color :   green , \n   },  }  // good  { \n   bruceBanner :   { \n     color :   pink , \n     transition :   color 10s , \n   }, \n\n   bruceBanner_theHulk :   { \n     color :   green , \n   },  }    Use  selectorName_fallback  for sets of fallback styles.    Why? Similar to modifiers, keeping the naming consistent helps reveal the relationship of these styles to the styles that override them in more adequate browsers.   // bad  { \n   muscles :   { \n     display :   flex , \n   }, \n\n   muscles_sadBears :   { \n     width :   100% , \n   },  }  // good  { \n   muscles :   { \n     display :   flex , \n   }, \n\n   muscles_fallback :   { \n     width :   100% , \n   },  }    Use a separate selector for sets of fallback styles.    Why? Keeping fallback styles contained in a separate object clarifies their purpose, which improves readability.   // bad  { \n   muscles :   { \n     display :   flex , \n   }, \n\n   left :   { \n     flexGrow :   1 , \n     display :   inline-block , \n   }, \n\n   right :   { \n     display :   inline-block , \n   },  }  // good  { \n   muscles :   { \n     display :   flex , \n   }, \n\n   left :   { \n     flexGrow :   1 , \n   }, \n\n   left_fallback :   { \n     display :   inline-block , \n   }, \n\n   right_fallback :   { \n     display :   inline-block , \n   },  }    Use device-agnostic names (e.g. \"small\", \"medium\", and \"large\") to name media query breakpoints.    Why? Commonly used names like \"phone\", \"tablet\", and \"desktop\" do not match the characteristics of the devices in the real world. Using these names sets the wrong expectations.   // bad  const   breakpoints   =   { \n   mobile :   @media (max-width: 639px) , \n   tablet :   @media (max-width: 1047px) , \n   desktop :   @media (min-width: 1048px) ,  };  // good  const   breakpoints   =   { \n   small :   @media (max-width: 639px) , \n   medium :   @media (max-width: 1047px) , \n   large :   @media (min-width: 1048px) ,  };",
            "title": "Naming"
        },
        {
            "location": "/js/css-js/#ordering",
            "text": "Define styles after the component.    Why? We use a higher-order component to theme our styles, which is naturally used after the component definition. Passing the styles object directly to this function reduces indirection.   // bad\nconst styles = {\n  container: {\n    display:  inline-block ,\n  },\n};\n\nfunction MyComponent({ styles }) {\n  return (\n     div {...css(styles.container)} \n      Never doubt that a small group of thoughtful, committed citizens can\n      change the world. Indeed, it\u2019s the only thing that ever has.\n     /div \n  );\n}\n\nexport default withStyles(() =  styles)(MyComponent);\n\n\n// good\nfunction MyComponent({ styles }) {\n  return (\n     div {...css(styles.container)} \n      Never doubt that a small group of thoughtful, committed citizens can\n      change the world. Indeed, it\u2019s the only thing that ever has.\n     /div \n  );\n}\n\nexport default withStyles(() =  ({\n  container: {\n    display:  inline-block ,\n  },\n}))(MyComponent);",
            "title": "Ordering"
        },
        {
            "location": "/js/css-js/#nesting",
            "text": "Leave a blank line between adjacent blocks at the same indentation level.    Why? The whitespace improves readability and reduces the likelihood of merge conflicts.   // bad  { \n   bigBang :   { \n     display :   inline-block , \n     ::before :   { \n       content :   , \n     }, \n   }, \n   universe :   { \n     border :   none , \n   },  }  // good  { \n   bigBang :   { \n     display :   inline-block , \n\n     ::before :   { \n       content :   , \n     }, \n   }, \n\n   universe :   { \n     border :   none , \n   },  }",
            "title": "Nesting"
        },
        {
            "location": "/js/css-js/#inline",
            "text": "Use inline styles for styles that have a high cardinality (e.g. uses the value of a prop) and not for styles that have a low cardinality.    Why? Generating themed stylesheets can be expensive, so they are best for discrete sets of styles.   // bad\nexport default function MyComponent({ spacing }) {\n  return (\n     div style={{ display:  table , margin: spacing }} / \n  );\n}\n\n// good\nfunction MyComponent({ styles, spacing }) {\n  return (\n     div {...css(styles.periodic, { margin: spacing })} / \n  );\n}\nexport default withStyles(() =  ({\n  periodic: {\n    display:  table ,\n  },\n}))(MyComponent);",
            "title": "Inline"
        },
        {
            "location": "/js/css-js/#themes",
            "text": "Use an abstraction layer such as  react-with-styles  that enables theming.  react-with-styles gives us things like  withStyles() ,  ThemedStyleSheet , and  css()  which are used in some of the examples in this document.    Why? It is useful to have a set of shared variables for styling your components. Using an abstraction layer makes this more convenient. Additionally, this can help prevent your components from being tightly coupled to any particular underlying implementation, which gives you more freedom.    Define colors only in themes.   // bad  export   default   withStyles (()   =   ({ \n   chuckNorris :   { \n     color :   #bada55 , \n   },  }))( MyComponent );  // good  export   default   withStyles (({   color   })   =   ({ \n   chuckNorris :   { \n     color :   color . badass , \n   },  }))( MyComponent );    Define fonts only in themes.   // bad  export   default   withStyles (()   =   ({ \n   towerOfPisa :   { \n     fontStyle :   italic , \n   },  }))( MyComponent );  // good  export   default   withStyles (({   font   })   =   ({ \n   towerOfPisa :   { \n     fontStyle :   font . italic , \n   },  }))( MyComponent );    Define fonts as sets of related styles.   // bad  export   default   withStyles (()   =   ({ \n   towerOfPisa :   { \n     fontFamily :   Italiana,  Times New Roman , serif , \n     fontSize :   2em , \n     fontStyle :   italic , \n     lineHeight :   1.5 , \n   },  }))( MyComponent );  // good  export   default   withStyles (({   font   })   =   ({ \n   towerOfPisa :   { \n     ... font . italian , \n   },  }))( MyComponent );    Define base grid units in theme (either as a value or a function that takes a multiplier).   // bad  export   default   withStyles (()   =   ({ \n   rip :   { \n     bottom :   -6912px ,   // 6 feet \n   },  }))( MyComponent );  // good  export   default   withStyles (({   units   })   =   ({ \n   rip :   { \n     bottom :   units ( 864 ),   // 6 feet, assuming our unit is 8px \n   },  }))( MyComponent );  // good  export   default   withStyles (({   unit   })   =   ({ \n   rip :   { \n     bottom :   864   *   unit ,   // 6 feet, assuming our unit is 8px \n   },  }))( MyComponent );    Define media queries only in themes.   // bad  export   default   withStyles (()   =   ({ \n   container :   { \n     width :   100% , \n\n     @media (max-width: 1047px) :   { \n       width :   50% , \n     }, \n   },  }))( MyComponent );  // good  export   default   withStyles (({   breakpoint   })   =   ({ \n   container :   { \n     width :   100% , \n\n     [ breakpoint . medium ] :   { \n       width :   50% , \n     }, \n   },  }))( MyComponent );    Define tricky fallback properties in themes.    Why? Many CSS-in-JavaScript implementations merge style objects together which makes specifying fallbacks for the same property (e.g.  display ) a little tricky. To keep the approach unified, put these fallbacks in the theme.   // bad  export   default   withStyles (()   =   ({ \n   . muscles   { \n     display :   flex , \n   }, \n\n   . muscles_fallback   { \n     display  :   table , \n   },  }))( MyComponent );  // good  export   default   withStyles (({   fallbacks   })   =   ({ \n   . muscles   { \n     display :   flex , \n   }, \n\n   . muscles_fallback   { \n     [ fallbacks . display ] :   table , \n   },  }))( MyComponent );  // good  export   default   withStyles (({   fallback   })   =   ({ \n   . muscles   { \n     display :   flex , \n   }, \n\n   . muscles_fallback   { \n     [ fallback ( display )] :   table , \n   },  }))( MyComponent );     Create as few custom themes as possible. Many applications may only have one theme.    Namespace custom theme settings under a nested object with a unique and descriptive key.    // bad  ThemedStyleSheet . registerTheme ( mySection ,   { \n   mySectionPrimaryColor :   green ,  });  // good  ThemedStyleSheet . registerTheme ( mySection ,   { \n   mySection :   { \n     primaryColor :   green , \n   },  });    CSS puns adapted from  Saijo George .",
            "title": "Themes"
        },
        {
            "location": "/php/php/",
            "text": "Venngage PHP Style Guide\n\n\n**",
            "title": "PHP Styleguide"
        },
        {
            "location": "/php/php/#venngage-php-style-guide",
            "text": "**",
            "title": "Venngage PHP Style Guide"
        },
        {
            "location": "/about/license/",
            "text": "(The MIT License)\n\n\nCopyright (c) 2014-2017 Airbnb\n\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
            "title": "License"
        }
    ]
}